#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Chapter::Closed:: *)
(*Definitions*)


(* ::Section::Closed:: *)
(*Initializations*)


(* ::Subsection::Closed:: *)
(*Package loading*)


PackageVersion="5.0.9";
Init[PackageVersion]


Needs["Developer`"]


Off[SFT::"NewPlan"]
Off[ToLyotPlane::"NewPlan"]
SetOptions[ListLogPlot,Joined->True,Frame->True,Axes->None,PlotStyle->AbsoluteThickness[1.5]];


(* ::Chapter:: *)
(*Directory*)


(* ::Section:: *)
(*File Directory*)


(* ::Subsection:: *)
(*Directory of the HiCAT files*)


FileDirectoryHiCATFiles= "/user/kstlaurent/git/progressive_refinement_coronagraphy/apodizers/"


(* ::Chapter::Closed:: *)
(*Functions*)


(* ::Section::Closed:: *)
(*Padding for File Name *)


(* ::Text:: *)
(*Function to pad string numbers and complete with zeros in front *)


PaddingForFileNames[x_,ndigit_]:=PaddedForm[x,ndigit,NumberPadding->{"0",""},NumberSigns->{"",""}]//ToString


(* ::Section::Closed:: *)
(*Full pupil generation*)


(* ::Subsection:: *)
(*From quarter pupil*)


FullPupilFromQuarterGenerationFunction[ArrayQuarter_, nPup_]:= Module[{ArrayFromQuarter, ArrayOtherQuarter, ArrayOtherHalfQ, ArrayOtherQuarter2},
ArrayFromQuarter=Table[0., {i, 1, nPup}, {j, 1, nPup}];
ArrayFromQuarter[[nPup/2+1;;nPup, nPup/2+1;;nPup]]=ArrayQuarter;
ArrayOtherQuarter=Table[ArrayQuarter[[i, nPup/2+1 - j]], {i, 1, nPup/2},{j, 1, nPup/2}];
ArrayFromQuarter[[ nPup/2+1;;nPup,1;;nPup/2]]=ArrayOtherQuarter;
ArrayOtherHalfQ=Table[ArrayFromQuarter[[ i, j]], {i, nPup/2+1, nPup},{j, 1, nPup}];
ArrayOtherQuarter2=Table[ ArrayOtherHalfQ[[nPup/2+1-i, j]], {i, 1, nPup/2},{j, 1, nPup}];
ArrayFromQuarter[[1;;nPup/2, All]]=ArrayOtherQuarter2;
ArrayFromQuarter
]


(* ::Subsection::Closed:: *)
(*From half pupil*)


FullPupilFromHalfGenerationFunction[PupilHalf_, nPup_]:=Module[{PupilFromHalf,PupilOtherHalf},
PupilFromHalf=Table[0., {i, 1, nPup}, {j, 1, nPup}];
PupilFromHalf[[All, nPup/2+1;;nPup]]=PupilHalf;
PupilOtherHalf=Table[PupilHalf[[i, nPup/2+1 - j]], {i, 1, nPup},{j, 1, nPup/2}];
PupilFromHalf[[ All,1;;nPup/2]]=PupilOtherHalf;
PupilFromHalf
]


(* ::Section::Closed:: *)
(*Array Size Increase*)


(* ::Subsection:: *)
(*Size increase*)


(* ::Text:: *)
(*Function to oversize a given array by an integer factor and inclusion of the values from the original array*)


SizeIncrease=Compile[{{image,_Real,2},{coeff,_Integer}},Module[{i,j,i0,j0,n,res},
n=Length[image]*coeff;
res=Table[0.,{n},{n}];
Do[
Do[
i0=Quotient[i+coeff-1,coeff];
j0=Quotient[j+coeff-1,coeff];
res[[i,j]]=image[[i0, j0]];
,{i,1,n}];
,{j,1,n}];
res
]
];


(* ::Subsection:: *)
(*Size increase and round*)


(* ::Text:: *)
(*Function to oversize a given array by an integer factor and inclusion of the rounded values from the original array*)


SizeIncreaseAndRound = Compile[{{image, _Real, 2}, {coeff, _Integer}}, Module[{i, j, i0, j0, n, res},
    n = Length[image]*coeff;
    res = Table[0., {n}, {n}];
    Do[
     Do[
       i0 = Quotient[i + coeff - 1, coeff];
       j0 = Quotient[j + coeff - 1, coeff];
       res[[i, j]] = Round[image[[i0, j0]]];
       , {i, 1, n}];
     , {j, 1, n}];
    res
    ]
   ];


(* ::Subsection:: *)
(*Size increase and binarization*)


(* ::Text:: *)
(*Function to oversize a given array by an integer factor and inclusion of the values from the original array after binarization*)


SizeIncreaseAndBinarization=Compile[{{image,_Real,2},{coeff,_Integer}},Module[{i,j,i0,j0,n,res, frac, i1, j1, k1,test},
n=Length[image]*coeff;
res=Table[0.,{n},{n}];
frac=1./(coeff^2+1);
Do[
Do[
i0=Quotient[i+coeff-1,coeff];
j0=Quotient[j+coeff-1,coeff];

i1=Mod[i+coeff-1, coeff];
j1=Mod[j+coeff-1, coeff];
k1=i1*coeff+j1+1;
test=Quotient[image[[i0, j0]],frac ];
res[[i,j]]=If[ test >=  k1,1.,0.];
,{i,1,n}];
,{j,1,n}];
res
]
];


(* ::Subsection:: *)
(*Size increase and random dither algorithm*)


(* ::Text:: *)
(*Function to oversize a given array by an integer factor and inclusion of values from the original array after random dither algorithm*)


SizeIncreaseAndRandomDither=Compile[{{image,_Real,2},{coeff,_Integer}},Module[{i,j,i0,j0,n,res},
n=Length[image]*coeff;
res=Table[0.,{n},{n}];
Do[
Do[
i0=Quotient[i+coeff-1,coeff];
j0=Quotient[j+coeff-1,coeff];
res[[i,j]]=If[RandomVariate[UniformDistribution[{0,1}]] <= image[[i0, j0]], 1., 0.];
,{i,1,n}];
,{j,1,n}];
res
]
];


(* ::Section::Closed:: *)
(*Size increase and error diffusion algorithm*)


(* ::Text:: *)
(*Function to oversize a given array by an integer factor and inclusion of values from the original array after error diffusion algorithm (e.g. Dorrer & Zuegel 2007)*)


SizeIncreaseAndErrorDiffusion=Compile[{{image,_Real,2},{coeff,_Integer}},Module[{i,j,n,res,err, SuperImage},
n=Length[image]*coeff;
res=Table[0.,{n},{n}];
err=Table[0.,{n},{n}];
SuperImage=SizeIncrease[image, coeff];
(*Print[Dimensions[SuperImage]];*)
Do[
Do[
If[SuperImage[[i,j]] > 0.5,res[[i,j]]=1., res[[i, j]]=0.];
err[[i,j]]=res[[i,j]]-SuperImage[[i,j]];
If[ i+1 <= n && j-1 <= n  && j-1 >= 1 , SuperImage[[i+1, j-1]]=SuperImage[[i+1, j-1]]+-3./16. *err[[i,j]]];
If[ i+1 <= n && j+0 <= n , SuperImage[[i+1, j+0]]=SuperImage[[i+1, j+0]]+-5./16. *err[[i,j]]];
If[ i+1 <= n && j+1 <= n , SuperImage[[i+1, j+1]]=SuperImage[[i+1, j+1]]+-1./16. *err[[i,j]]];
If[ i +0<= n && j+1 <= n , SuperImage[[i+0, j+1]]=SuperImage[[i+0, j+1]]+-7./16. *err[[i,j]]];
,{j,1,n}];
,{i,1,n}];
res
]
];


(* ::Section::Closed:: *)
(*ToLyotPlane center*)


(* ::Text:: *)
(*ToLyotPlaneCenter function reproduces the ToLyotPlane function that is used in Coronagraphy package to make propagation for pupils centered between four pixels*)


(* ::Subsection:: *)
(*PlaneToLyotPlaneCenter*)


CurrentExistingPlan={};
Options[PlanToLyotPlaneCenter]={MaskSampling->100,Wavelength->1,OverSizeLyot->1,OverSizePupil->1,SoftMask->False};
PlanToLyotPlaneCenter[Pupil_,Mask\[Lambda]surD_,Opt:OptionsPattern[]]:=Module[{n,nMask,Foyer,DiffractedWave,\[Lambda],CoeffOverSize,CoeffOverSizePup,centeringstyle},
n=Dimensions[Pupil][[1]];
nMask= OptionValue[MaskSampling];
\[Lambda]= OptionValue[Wavelength];
CoeffOverSize=OptionValue[OverSizeLyot];
CoeffOverSizePup=OptionValue[OverSizePupil];
TestSoft= OptionValue[SoftMask];
OptsSFT=Sequence@@FilterRules[Flatten[{Opt}],Options[SFT]];
nMask= OptionValue[MaskSampling];
CurrentExistingPlan={n,Mask\[Lambda]surD,nMask,\[Lambda],CoeffOverSize,CoeffOverSizePup,TestSoft};If[TestSoft==True,Mask=Developer`ToPackedArray[Cr\[EAcute]eDiaphragmeLisseCenter[nMask/2,nMask+10,5]];PlanSFT[Pupil,(CoeffOverSizePup Mask\[Lambda]surD (nMask+10))/(\[Lambda] nMask),nMask+10, Centering -> "NoPixel"];PlaniSFT[Mask,1/(nMask \[Lambda]) (nMask+10) CoeffOverSizePup CoeffOverSize Mask\[Lambda]surD,CoeffOverSize n, Centering -> "NoPixel"],Mask=Developer`ToPackedArray[Cr\[EAcute]eDiaphragmeCenter[nMask/2,nMask]];
PlanSFT[Pupil,(CoeffOverSizePup Mask\[Lambda]surD)/\[Lambda],nMask, Centering -> "NoPixel"];PlaniSFT[Mask,(CoeffOverSizePup CoeffOverSize Mask\[Lambda]surD)/\[Lambda],CoeffOverSize n, Centering -> "NoPixel"];]]



(* ::Subsection::Closed:: *)
(*ToLyotPlaneCenter*)


Protect[MaskSampling,Wavelength,OverSizeLyot,OverSizePupil];
Options[ToLyotPlaneCenter]={MaskSampling->100,Wavelength->1,OverSizeLyot->1,OverSizePupil->1,SoftMask->False};
ToLyotPlaneCenter::"NewPlan"="Calculating new SFT and iSFT plans...";
ToLyotPlaneCenter[Pupil_,Mask\[Lambda]surD_,Opt:OptionsPattern[]]:=Module[{n,nMask,Foyer,DiffractedWave,\[Lambda],CoeffOverSize,CoeffOverSizePup,centeringstyle},
n=Dimensions[Pupil][[1]];
nMask=OptionValue[MaskSampling];
\[Lambda]=OptionValue[Wavelength];
CoeffOverSize= OptionValue[OverSizeLyot];
CoeffOverSizePup=OptionValue[OverSizePupil];
TestSoft=OptionValue[SoftMask];
If[CurrentExistingPlan!={n,Mask\[Lambda]surD,nMask,\[Lambda],CoeffOverSize,CoeffOverSizePup,TestSoft},Message[ToLyotPlaneCenter::"NewPlan"];NewOpts={MaskSampling->nMask,Wavelength->\[Lambda],OverSizeLyot->CoeffOverSize,OverSizePupil->CoeffOverSizePup,SoftMask->TestSoft};PlanToLyotPlaneCenter[Pupil,Mask\[Lambda]surD,NewOpts]];
If[TestSoft==True,
Foyer=SFT[Pupil,(CoeffOverSizePup Mask\[Lambda]surD (nMask+10))/(\[Lambda] nMask),nMask+10, Centering -> "NoPixel"];DiffractedWave=iSFT[Mask Foyer,1/(nMask \[Lambda]) (nMask+10) CoeffOverSizePup CoeffOverSize Mask\[Lambda]surD,CoeffOverSize n, Centering -> "NoPixel"];DiffractedWave=Resize[Pupil,CoeffOverSize n]-DiffractedWave,
Foyer=Developer`ToPackedArray[SFT[Pupil,(CoeffOverSizePup Mask\[Lambda]surD)/\[Lambda],nMask, Centering -> "NoPixel"]];DiffractedWave=Developer`ToPackedArray[iSFT[Mask Foyer,(CoeffOverSizePup CoeffOverSize Mask\[Lambda]surD)/\[Lambda],CoeffOverSize n, Centering -> "NoPixel"]];DiffractedWave=Developer`ToPackedArray[Resize[Pupil,CoeffOverSize n]-DiffractedWave]]];



(* ::Section::Closed:: *)
(*Functions for Airy throughput computation*)


(* ::Subsection:: *)
(*Make circ*)


(* ::Text:: *)
(*Make centered circle with given radius and array size as parameters*)


MakeCirc=Compile[{i,j,\[Rho],n0},If[Sqrt[(i-n0)^2+(j-n0)^2]<=\[Rho] ,1,0]];
Cr\[EAcute]eCirc[\[Rho]1_, n_]:=Module[{i,j,n0},
									    n0=n/2+1/2;
									    Table[MakeCirc[i,j,\[Rho]1,n0],{i,n},{j,n}]
									 ];


(* ::Subsection::Closed:: *)
(*Make decentered circ*)


(* ::Text:: *)
(*Make offset circle with given radius, array size, and offset values wrt to the center as parameters *)


MakeDecenteredCirc=Compile[{i,j,\[Rho],n1, n2},If[Sqrt[(i-n1)^2+(j-n2)^2]<=\[Rho] ,1,0]];
Cr\[EAcute]eDecenteredCirc[\[Rho]1_, n_, xdc_, ydc_]:=Module[{i,j,n1,n2},
									    n1=n/2+1/2+ydc;
									n2=n/2+1/2+xdc;
									    Table[MakeDecenteredCirc[i,j,\[Rho]1,n1, n2],{i,n},{j,n}]
									 ];


(* ::Section::Closed:: *)
(*Contrast List Plot*)


ContrastListPlot[PreListPlot_, MMaskProj_, \[Rho]0_, \[Rho]1_, cCoreRegion_, cSecondaryRegion_, PlotLabelPsfBw_,MaxX_]:=Module[{},
ListPlot[PreListPlot,Joined->True, PlotRange-> {{-0.5,MaxX}, {-1.8, -12.2}}, ImageSize-> Large,LabelStyle->Directive[FontFamily->"Helvetica", FontSize-> 15.], 
 FrameLabel-> {"Angular separation in \!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", "Normalized intensity in log scale"},
FrameStyle-> AbsoluteThickness[1.1],
PlotStyle->If[Length[PreListPlot] ==1, Directive[ColorData["Rainbow", 0],AbsoluteThickness[2.0]], Table[Directive[ColorData["Rainbow",i/(Length[PreListPlot]-1)], AbsoluteThickness[2.0]],{i,0,Length[PreListPlot]-1}]],
Epilog ->{FontSize -> 15.,AbsoluteThickness[2.0],{Dashed,Blue, Line[{{{\[Rho]0, 0}, {\[Rho]0, -20}}, {{\[Rho]1, 0}, {\[Rho]1, -20}}}]}, 
{Dotted, Red, Line[{{MMaskProj, 0}, {MMaskProj, -20}}]}, 
{Black, Line[{{\[Rho]0,Log10[cDarkHoleRegion]},{\[Rho]1,Log10[cDarkHoleRegion]}}]},
{Black,  Line[{{0.,Log10[cCoreRegion]},{\[Rho]0,Log10[cCoreRegion]}}]},
{Black,  Line[{{\[Rho]1,Log10[cSecondaryRegion]},{50.,Log10[cSecondaryRegion]}}]},
(*{Black,  Line[{{\[Rho]0,Log10[cDarkHoleRegion]},{50,Log10[cDarkHoleRegion]}}]},*)
{Inset[Style["m/2=" <>ToString[PaddedForm[MMaskProj, {3, 2}]] <>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Red, FontFamily -> "Helvetica"],  {MMaskProj+ 5., -3.}] },
{Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(i\)]\)=" <> ToString[PaddedForm[\[Rho]0, {2, 1}]]<>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Blue, FontFamily -> "Helvetica"],  {\[Rho]0+4., -2.5}] },
{Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(o\)]\)=" <> ToString[PaddedForm[\[Rho]1, {2, 1}]]<>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Blue, FontFamily -> "Helvetica"],  {\[Rho]1+5, -2.5}] },
{Inset[Style[PlotLabelPsfBw, FontFamily -> "Helvetica"],  {40, -11}] }
}]
]


PSFContrastListPlot[PreListPlot_, MMaskProj_, PSF\[Rho]0_, PSF\[Rho]1_, cPSFCoreRegion_, cPSFSecondaryRegion_, PlotLabelPsfBw_,MaxX_]:=Module[{},
ListPlot[PreListPlot,Joined->True, PlotRange-> {{-0.5,MaxX}, {-1.8, -12.2}}, ImageSize-> Large,LabelStyle->Directive[FontFamily->"Helvetica", FontSize-> 15.], 
 FrameLabel-> {"Angular separation in \!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", "Normalized intensity in log scale"},
FrameStyle-> AbsoluteThickness[1.1],
PlotStyle->If[Length[PreListPlot] ==1, Directive[ColorData["Rainbow", 0],AbsoluteThickness[2.0]], Table[Directive[ColorData["Rainbow",i/(Length[PreListPlot]-1)], AbsoluteThickness[2.0]],{i,0,Length[PreListPlot]-1}]],
Epilog ->{FontSize -> 15.,AbsoluteThickness[2.0],{Dashed,Blue, Line[{{{PSF\[Rho]0, 0}, {PSF\[Rho]0, -20}}, {{PSF\[Rho]1, 0}, {PSF\[Rho]1, -20}}}]}, 
{Dotted, Red, Line[{{MMaskProj, 0}, {MMaskProj, -20}}]}, 
{Black, Line[{{PSF\[Rho]0,Log10[cPSFDarkHoleRegion]},{PSF\[Rho]1,Log10[cPSFDarkHoleRegion]}}]},
{Black,  Line[{{0.,Log10[cPSFCoreRegion]},{PSF\[Rho]0,Log10[cPSFCoreRegion]}}]},
{Black,  Line[{{PSF\[Rho]1,Log10[cPSFSecondaryRegion]},{50.,Log10[cPSFSecondaryRegion]}}]},
(*{Black,  Line[{{\[Rho]0,Log10[cDarkHoleRegion]},{50,Log10[cDarkHoleRegion]}}]},*)
{Inset[Style["m/2=" <>ToString[PaddedForm[MMaskProj, {3, 2}]] <>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Red, FontFamily -> "Helvetica"],  {MMaskProj+ 5., -3.}] },
{Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(i\)]\)=" <> ToString[PaddedForm[PSF\[Rho]0, {2, 1}]]<>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Blue, FontFamily -> "Helvetica"],  {PSF\[Rho]0+4., -2.5}] },
{Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(o\)]\)=" <> ToString[PaddedForm[PSF\[Rho]1, {2, 1}]]<>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Blue, FontFamily -> "Helvetica"],  {PSF\[Rho]1+5, -2.5}] },
{Inset[Style[PlotLabelPsfBw, FontFamily -> "Helvetica"],  {40, -11}] }
}]
]


(* ::Section::Closed:: *)
(*Pupil plane Array Plot*)


PupilPlaneArrayPlot[PreArrayPlot_]:=Module[{},
Legended[ArrayPlot[PreArrayPlot, ColorFunction -> "SunsetColors", Frame -> False,PlotRange-> {0., 1.}],
 BarLegend[{"SunsetColors", {0., 1.}}, LegendMargins->10,  LegendMarkerSize -> 375, LabelStyle->Directive[FontFamily->"Helvetica", FontSize -> 20.]]
]
]


(* ::Section::Closed:: *)
(*Image Plane Array Plot*)


ImagePlaneArrayPlot[PreArrayPlot_]:=Module[{},
ArrayPlot[Log10[PreArrayPlot], ColorFunction -> ColorData["Rainbow"], Frame->False, PlotRange->{-12,-2},
    PlotLegends -> BarLegend[{ColorData[{"Rainbow", "Reverse"}], {-12, -2}},
                              LabelStyle -> Directive[FontFamily->"Helvetica", FontSize -> 20.],
                              LegendMargins->10, LegendMarkerSize -> 375
                              
    ]
]
]


(* ::Chapter:: *)
(*Parameters*)


(* ::Section:: *)
(*Tunable Parameters*)


(* ::Subsection:: *)
(*Keywords*)


(* ::Text:: *)
(*Keyword to export the final apodizer*)


KeywordExportFitsFiles=1;


(* ::Text:: *)
(*Keyword to add in a prolate or preapodized aperture*)


ProlateKeyword=1;
gaussian = "3030";
rescale = "50";


(* ::Subsection:: *)
(*Pupil Size, Mask Sampling, Image Plane Sampling*)


(* ::Text:: *)
(*Pupil size*)


nPup=121*2;


(* ::Text:: *)
(*FPM sampling (by default, MaskSampling is equal to 100 pixels in ToLyotPlane functions)*)


MaskSampling0=50*2;


(* ::Text:: *)
(*Relative mask radius (in \[Lambda]0/D0 unit, where D0 denotes the aperture(APODIZER) diameter - do not change the name to Mask, variable is already used in ToLyotPlane functions) *)
(*FPM1 = 3.1355 lam/D*)
(*FPM2 = 4.2715 lam/D*)


FPM = 2;


(* ::Text:: *)
(*Undersizing of the Lyot stop wrt to the aperture dimensions*)


UndersizedPup=0.830;


(* ::Text:: *)
(*Maximum spatial frequency in the final image plane (in \[Lambda]0/D0 unit, where D0 denotes the aperture diameter) and sizes for 2D array*)


nFmax = 16/UndersizedPup(*60.0;*)(*75.;*)
nFmax2D=2.*nFmax;


(* ::Text:: *)
(*Array size in the final image plane*)


nImg = 32;(*240.0;*)(*384;*)
nImg2D=2*nImg;


(* ::Text:: *)
(*Oversizing factor to increase the size of the pupil arrays*)


MultFactor = 0.25;
ResizingFactor=4;


(* ::Subsection:: *)
(*Constraints (Dark Zone and Direct PSF)*)


(* ::Text:: *)
(*Dark zone boundaries (\[Rho]0 and \[Rho]1, inner and outer edges in \[Lambda]0/D, where D denotes the pupil diameter), *)
(*\[Rho]0= 2.0 and 3.0 \[Lambda]0/D for MMask =  6.271/2 and MMask=8.543/2 \[Lambda]0/D resp.*)


\[Rho]0=3.75;
\[Rho]1=15.00;


(* ::Text:: *)
(*Contrast target for each region*)


cCoreRegion=10.^-3;
cDarkHoleRegion=10.^-8;
cSecondaryRegion = cDarkHoleRegion;


(* ::Text:: *)
(*Constraint on the direct PSF*)


PSFKeyword = 0;


(* ::Text:: *)
(*Dark zone boundaries for the direct PSF*)


PSF\[Rho]0 = 14.75;
PSF\[Rho]1 = 57.00;


(* ::Text:: *)
(*Contrast target for each region*)


cPSFCoreRegion = 10.^-1;
cPSFDarkHoleRegion = 10.^-1;
cPSFSecondaryRegion = cPSFDarkHoleRegion;


(* ::Subsection:: *)
(*Wavelength*)


(* ::Text:: *)
(*Central wavelength \[Lambda]0 (arbitrary unit), bandwidth \[CapitalDelta]\[Lambda] in \[Lambda]0 unit, and wavelength sampling (1- used in the solver, 2- used for the present computation)*)


\[Lambda]0=1.;
bandwidth=0.10;
\[CapitalDelta]\[Lambda]=bandwidth*\[Lambda]0;
n\[Lambda]Solver=3;
n\[Lambda]=3;


(* ::Subsection:: *)
(*Lyot Stop shifts*)


(* ::Text:: *)
(*Number of shifts, ShiftStep in pixels (0 for no shifts/lyot robustness turned off, 0.50 to turn on), and shift direction*)


nShift=5;
ShiftStep=0.50;
YaxisShiftKeyword=0;


(* ::Section::Closed:: *)
(*Units*)


(* ::Text:: *)
(*Definition of units*)


mm=10.^-3;
\[Mu]m=10.^-6;
nm=10.^-9;


(* ::Section::Closed:: *)
(*Partial pupil*)


(* ::Text:: *)
(*Keyword to define whether optimization was made over quarter pupil or half pupil (Full keyword =1 for robust designs - TBT)*)


QuarterKeyword=0;
FullKeyword=1;


(* ::Text:: *)
(*Parameters from HiCATApertureGeneration*)


ApodizerMaskUndersizeContour=0.972;
ApodizerMaskOversizeCentralSegmentRatioIrisAO=0.195;
SymSpidersKeyword=1;
ApodizerMaskSpidersThickRatioIrisAO=0.017;
ApodizerMaskGapHexagonRatioIrisAO= 0.004;


(* ::Text:: *)
(*Robust design (remember that AMPL generates the full aperture instead of the quarter one)*)


MaxShiftStepPix=0;
LyotRobustnessKeyword=0;


(* ::Section:: *)
(*Resized factor*)


(* ::Text:: *)
(*Oversizing factor to increase the size of the pupil arrays*)


nPupSuper=ResizingFactor*nPup;


(* ::Text:: *)
(*Keyword to round the values of the apodizer in the absence of oversizing factor*)


RoundApodKeyword=0;


(* ::Section::Closed:: *)
(*Focal plane mask*)


(* ::Text:: *)
(*Relative mask radius (in \[Lambda]0/D0 unit, where D0 denotes the aperture diameter - do not change the name to Mask, variable is already used in ToLyotPlane functions)*)


MMask1 = 6.271/2;
MMask2 = 8.543/2;
If[FPM == 1, MMask = MMask1, MMask = MMask2];


(* ::Section::Closed:: *)
(*Wavelength*)


(* ::Text:: *)
(*Arrays of wavelengths (1- used in the Optmizer, 2- used for the present computation)*)


If[n\[Lambda]Solver == 1, 
\[Lambda]TableSolver={\[Lambda]0},
\[Lambda]TableSolver=Table[\[Lambda]0*(1+ ((i\[Lambda]-1)/(n\[Lambda]Solver-1.)-0.5)*\[CapitalDelta]\[Lambda]), {i\[Lambda], 1, n\[Lambda]Solver}]];
If[n\[Lambda] == 1, 
\[Lambda]Table={\[Lambda]0},
\[Lambda]Table=Table[\[Lambda]0*(1+ ((i\[Lambda]-1)/(n\[Lambda]-1.)-0.5)*\[CapitalDelta]\[Lambda]), {i\[Lambda], 1, n\[Lambda]}]];


(* ::Text:: *)
(*Wavelength on the HiCAT testbed*)


\[Lambda]HiCAT=639.8 nm;


(* ::Section::Closed:: *)
(*Lyot stop*)


(* ::Subsection:: *)
(*Parameters from HiCATApertureGeneration.nb*)


KeywordLyotStopGray=1;
LyotStopMaskCentralSegmentSizeRatioIrisAO=0.345;
LyotStopSizeRatioIrisAO=0.807;
LyotStopMaskSpidersThickRatioIrisAO=0.036;


(* ::Subsection:: *)
(*Dimensions*)


(* ::Text:: *)
(*Projected radius of the FPM in the final image plane (in \[Lambda]0/D unit) *)


MMaskProj=MMask*UndersizedPup;


(* ::Subsection:: *)
(*Shift versions of the Lyot stop*)


(* ::Text:: *)
(*Resizing of the original array size*)


nPupForLyotStopShift=nPup+20;


(* ::Text:: *)
(*Ratio between old and new sizes of the pupil arrays*)


LyotStopShiftResizingFactor=nPupForLyotStopShift/nPup//N;


(* ::Subsection::Closed:: *)
(*DM quilting effects*)


(* ::Text:: *)
(*WFE scaling of the DM phase map*)


DMPhaseMapIntroducedrmsWFE=10.nm;


(* ::Text:: *)
(*WFE map resizing FFT scaling factor*)


DMPhaseMapZeroPaddingFactor=4;


(* ::Text:: *)
(*Number of actuators across DM diameter and number of used actuators in HiCAT*)


nAct=34.;
nActUsed=29.8389;


(* ::Text:: *)
(*Hann Window to filter low-spatial frequencies on the WFE map*)


HannKeyword=0;


(* ::Section::Closed:: *)
(*Airy throughput*)


(* ::Text:: *)
(*Photometric aperture in lam0/D unit*)


PhotometricApertureDiamTable={1.5};(*{1.0, 1.5, 2.0, 2.5, 3.0}*)(*{0.5, 1.0, 1.5, 2.0, 3.0, 4.0, 5.0, 10., 20., 30., 40., 50., 60.,66.,70., 80.};*)
PhotometricApertureRadiusTable=PhotometricApertureDiamTable/2.;
nPhotometricAperture=Length[PhotometricApertureRadiusTable];
iPhotometricAperture0=1;


(* ::Chapter:: *)
(*File Import*)


(* ::Section::Closed:: *)
(*File nomenclature*)


(* ::Subsubsection:: *)
(*Roots*)


(* ::Subsubsection:: *)
(*File type*)


RootTestbed="HiCAT";
RootNameList={"-Aper","-Apod",  "-Lyot"};
RootPupilGeometry={"_F", "_H", "_Q"};
RootQuarterSize="-N" <> PaddingForFileNames[Round[nPup/2], 4]


(* ::Text:: *)
(*Quarter Plane*)


RootFileTypeAperQ = RootTestbed <> RootNameList[[1]] <> RootPupilGeometry[[3]] <> RootQuarterSize
RootFileTypeApodQ = RootTestbed <> RootNameList[[2]] <> RootPupilGeometry[[3]] <> RootQuarterSize
RootFileTypeLyotQ = RootTestbed <> RootNameList[[3]] <> RootPupilGeometry[[3]] <> RootQuarterSize


(* ::Text:: *)
(*Half Plane*)


RootFileTypeAperH = RootTestbed <> RootNameList[[1]] <> RootPupilGeometry[[2]] <> RootQuarterSize;
RootFileTypeApodH = RootTestbed <> RootNameList[[2]] <> RootPupilGeometry[[2]] <> RootQuarterSize;
RootFileTypeLyotH = RootTestbed <> RootNameList[[3]] <> RootPupilGeometry[[2]] <> RootQuarterSize;


(* ::Text:: *)
(*Full Plane*)


RootFileTypeAperF=RootTestbed <> RootNameList[[1]] <> RootPupilGeometry[[1]] <> RootQuarterSize;
RootFileTypeApodF=RootTestbed <> RootNameList[[2]] <> RootPupilGeometry[[1]] <> RootQuarterSize;
RootFileTypeLyotF=RootTestbed <> RootNameList[[3]] <> RootPupilGeometry[[1]] <> RootQuarterSize;


(* ::Subsubsection:: *)
(*Aperture type*)


RootAperType="_Hex3"
RootAperContour="-Ctr" <> PaddingForFileNames[Round[ApodizerMaskUndersizeContour*1000.], 4];
RootAperCentralSegment="-Obs" <> PaddingForFileNames[Round[ApodizerMaskOversizeCentralSegmentRatioIrisAO*1000.], 4];
RootAperSpiders="-Sp" <> If[SymSpidersKeyword==1,"X", "Y"] <> PaddingForFileNames[Round[ApodizerMaskSpidersThickRatioIrisAO*1000.], 4];
RootAperGap="-Gap" <> PaddingForFileNames[Round[ApodizerMaskGapHexagonRatioIrisAO*1000.], 4];



RootApertureType=RootAperType <> RootAperContour <> RootAperCentralSegment <> RootAperSpiders <>RootAperGap 


(* ::Subsubsection::Closed:: *)
(*FPM*)


RootFPMSizeList="_GreyFPM" <> PaddingForFileNames[Round[ MMask*2*1000.], 4];
RootFPMQuarterSize="-M" <> PaddingForFileNames[Round[MaskSampling0/2], 3];
RootFPM=RootFPMSizeList <> RootFPMQuarterSize


(* ::Subsubsection::Closed:: *)
(*Lyot stop*)


RootLyotType="_LS-Ann-" <> If[KeywordLyotStopGray==1, "gy", "bw"] ;
RootLyotStopID="-ID" <> PaddingForFileNames[Round[LyotStopMaskCentralSegmentSizeRatioIrisAO*1000.], 4];
RootLyotStopOD="-OD" <> PaddingForFileNames[Round[LyotStopSizeRatioIrisAO*1000.], 4];
RootLyotSpiders="-Sp" <> If[SymSpidersKeyword==1,"X", "Y"] <> PaddingForFileNames[Round[LyotStopMaskSpidersThickRatioIrisAO*1000.], 4];


RootLyot=RootLyotType <> RootLyotStopID <> RootLyotStopOD <> RootLyotSpiders


RootLyotRobustness=If[LyotRobustnessKeyword==1, "_shiftXY" <> PaddingForFileNames[Round[MaxShiftStepPix*100], 3],"" ]


(* ::Subsubsection::Closed:: *)
(*Dark zone*)


RootContrast="_DZ-C" <> PaddingForFileNames[Round[-Log10[cCoreRegion]*10], 3] <> "-" <>  PaddingForFileNames[Round[-Log10[cDarkHoleRegion]*10], 3] ;
RootSeparations="-Sep"<>PaddingForFileNames[IntegerPart[\[Rho]0*10.], 3]<>"-" <>PaddingForFileNames[Round[\[Rho]1*10.], 3] ;


RootDarkZone=RootContrast <> RootSeparations


(* ::Subsubsection::Closed:: *)
(*Direct PSF constraints*)


RootPSFContrast = "_PSFDZ-C"<> PaddingForFileNames[Round[-Log10[cPSFDarkHoleRegion]*10], 3];
RootPSFSeparations = "-PSFSep"<>PaddingForFileNames[Floor[PSF\[Rho]0*10.], 3]<>"-" <>PaddingForFileNames[Round[PSF\[Rho]1*10.], 3];
RootPSFDarkZone = If[PSFKeyword == 1,RootPSFContrast <> RootPSFSeparations, ""]


(* ::Subsubsection::Closed:: *)
(*Wavelength*)


RootBandwidth="_Bw" <>  PaddingForFileNames[Round[bandwidth*100],2];
RootWavelengthNb="-Lam3" (*<> PaddingForFileNames[Round[n\[Lambda]Solver],1]*);


RootWavelength=RootBandwidth <> RootWavelengthNb


(* ::Section:: *)
(*Filenames*)


(* ::Subsection:: *)
(*Pupil files - partial pupil*)


(* ::Subsubsection:: *)
(*Aperture*)


(* ::Text:: *)
(*Filename and fielpath for Aperture*)


FilenameApertureQuarter="input_files/aperture/"<>RootFileTypeAperQ <> RootApertureType <> ".dat";
FilenameApertureHalf="input_files/aperture/"<>RootFileTypeAperH <> RootApertureType <> ".dat";
FilenameApertureFull="input_files/aperture/"<>RootFileTypeAperF <> RootApertureType <> ".dat";
FilenameAperturePartial= If[QuarterKeyword==1,FilenameApertureQuarter,FilenameApertureFull];
(*FilenameAperturePartial = "input_files/aperture/HiCAT-Aper_NoSeg_F-N0243_Hex3-Ctr0972-Obs0195-SpX0017.dat"*)
(*FilenameAperturePartial = "input_files/aperture/HiCAT-Aper_NoSegNoSpid_F-N0243_Hex3-Ctr0972-Obs0195.dat"*)
(* FilenameAperturePartial = "input_files/aperture/HiCAT-Prolate_NoSegNoSpid_F-N0243_Hex3-Ctr0972-Obs0195.dat"*)
(*FilenameProlatePreApod = "input_files/prolate/ProlateApodizerScriptTest_VanillaApodizer_Gaussian"<>gaussian<>"_Rescaled"<>rescale<>".dat"*)
(*FilepathProlatePreApod = FileNameJoin[{FileDirectoryHiCATFiles, FilenameProlatePreApod}]*)
FilepathAperturePartial=FileNameJoin[{FileDirectoryHiCATFiles, FilenameAperturePartial}]


(* ::Subsubsection:: *)
(*Shaped pupil*)


(* ::Text:: *)
(*Filename and filepath for Shaped Pupil*)


FilenameShapedPupilQuarter="output_apodizers/dat/"<>RootFileTypeApodQ <> "_nImg"<>PaddingForFileNames[nImg, 4]<>RootApertureType <> RootFPM <> RootLyot <> RootDarkZone <> RootPSFDarkZone<>RootWavelength <> ".dat";
FilenameShapedPupilHalf="output_apodizers/dat/"<>RootFileTypeApodH <>"_nImg"<>PaddingForFileNames[nImg, 4]<> RootApertureType <> RootFPM <> RootLyot <> RootDarkZone <> RootPSFDarkZone<>RootWavelength <> RootLyotRobustness<>".dat";
FilenameShapedPupilFullNoLSR = "output_apodizers/dat/"<>RootFileTypeApodF <>"_nImg"<>PaddingForFileNames[nImg, 4]<> RootApertureType <> RootFPM <> RootLyot <> RootDarkZone <> RootPSFDarkZone<>RootWavelength <> ".dat";
FilenameShapedPupilFullLSR ="output_apodizers/dat/"<>RootFileTypeApodF <>"_nImg"<>PaddingForFileNames[nImg, 4]<> RootApertureType <> RootFPM <> RootLyot <> RootDarkZone <> RootPSFDarkZone<>RootWavelength <> RootLyotRobustness<>".dat";
FilenameShapedPupilFull = If[ShiftStep==0,FilenameShapedPupilFullNoLSR,FilenameShapedPupilFullLSR]; 
FilenameShapedPupilPartial=If[FullKeyword==1,FilenameShapedPupilFull, If[QuarterKeyword==1,FilenameShapedPupilQuarter,FilenameShapedPupilHalf]];
(*FilenameShapedPupilPartial = "output_apodizers/dat/PreApodization_Test4_Gaussian"<>gaussian<>"_Rescaled0"<>rescale<>"_broadband.dat"*)
FilepathShapedPupilPartial=FileNameJoin[{FileDirectoryHiCATFiles, FilenameShapedPupilPartial}]


(* ::Subsubsection:: *)
(*Lyot Stop *)


(* ::Text:: *)
(*Filename and filepath for Lyot Stop*)


FilenameLyotStopQuarter="input_files/lyot_stop/"<>RootFileTypeLyotQ <> RootLyot <> ".dat";
FilenameLyotStopHalf="input_files/lyot_stop/"<>RootFileTypeLyotH <> RootLyot <> ".dat";
FilenameLyotStopFull="input_files/lyot_stop/"<>RootFileTypeLyotF <> RootLyot <> "_shiftX+000" <>".dat";
FilenameLyotStopPartial=If[QuarterKeyword==1,FilenameLyotStopQuarter,FilenameLyotStopFull];
(*FilenameLyotStopPartial = "input_files/lyot_stop/HiCAT-Lyot_F-N0243_LS-Ann_NoSpid-gy-ID0345-OD0807_shiftX+000.dat"*)
FilepathLyotStopPartial=FileNameJoin[{FileDirectoryHiCATFiles, FilenameLyotStopPartial}]


(* ::Subsection::Closed:: *)
(*DM phase map*)


(* ::Text:: *)
(*DM phase map and numerical mask from 4D Fizeau interferometer*)
(*Data used for introduction of DM quilting effects*)


(* ::Subsubsection:: *)
(*DM phase map*)


(* ::Text:: *)
(*DM phase map from 4D*)


FilenameDMSurfaceMap="input_files/dm_surface_map/flatDM.fits";
FilepathDMSurfaceMap=FileNameJoin[{FileDirectoryHiCATFiles, FilenameDMSurfaceMap}]


(* ::Subsubsection:: *)
(*Numerical mask*)


(* ::Text:: *)
(*Numerical mask from 4D*)


FilenameDMMaskMap="input_files/dm_surface_map/maskDM.fits";
FilepathDMMaskMap=FileNameJoin[{FileDirectoryHiCATFiles, FilenameDMMaskMap}]


(* ::Section:: *)
(*Import*)


(* ::Subsection:: *)
(*FPM*)


FPMPartial=Import["/Users/kstlaurent/git/hicat-aplc/optimization/input_files/fpm/CircPupil_N=0050_coeff=0011_obs=00_center_quarter.dat"];
FPM= FullPupilFromQuarterGenerationFunction[FPMPartial, MaskSampling0];
FPMPupSize = ArrayPad[FPM,(nPup-MaskSampling0)/2];
ArrayPlot[FPMPupSize, ColorFunction -> GrayLevel, Frame -> True]
(*Export["/Users/kstlaurent/git/hicat-aplc/optimization/input_files/fpm/CircPupil_NArray0242_N=0050_coeff=0011_obs=00_center_quarter.fits",FPMPupSize]*)


(* ::Subsection:: *)
(*Aperture*)


(* ::Text:: *)
(*Import Aperture*)


AperturePartial=Import[FilepathAperturePartial];
ArrayPlot[AperturePartial, PlotRange-> All,ColorFunction ->GrayLevel]


(*ProlatePreApod = Import[FilepathProlatePreApod];
ArrayPlot[ProlatePreApod, PlotRange-> All,ColorFunction ->GrayLevel]*)


(*ArrayPlot[AperturePartial*ProlatePreApod, PlotRange-> All,ColorFunction ->GrayLevel]*)


(* ::Subsection:: *)
(*Shaped pupil*)


(* ::Text:: *)
(*Import Shaped Pupil (NB: ShapedPupil3DPartial contains three columns x, y, and transmission, values of interest are located in the third column)*)


ShapedPupil3DPartial=Import[FilepathShapedPupilPartial];
ShapedPupilDataPartial=ShapedPupil3DPartial[[All, 3]];
If[QuarterKeyword ==1,
ShapedPupilPartial=Partition[ShapedPupilDataPartial, nPup/2],
ShapedPupilPartial=Partition[ShapedPupilDataPartial, nPup]];
ArrayPlot[ShapedPupilPartial, ColorFunction -> GrayLevel]


(* ::Subsection:: *)
(*Lyot Stop*)


(* ::Text:: *)
(*Import Lyot stop*)


LyotStopPartial=Import[FilepathLyotStopPartial];
Dimensions[LyotStopPartial]
ArrayPlot[LyotStopPartial, PlotRange-> All,ColorFunction ->GrayLevel]


(* ::Input:: *)
(**)


(* ::Subsection::Closed:: *)
(*DM phase map and numerical mask from 4D data*)


(* ::Text:: *)
(*Import DM phase map and numerical mask from 4D data*)


DMMaskMap=Flatten[Import[FilepathDMMaskMap, "RawData"], 1];
DMSurfaceMap\[Mu]m=Flatten[Import[FilepathDMSurfaceMap, "RawData"], 1];
Dimensions[DMSurfaceMap\[Mu]m]
nDMMap=Length[DMSurfaceMap\[Mu]m]
(*ArrayPlot[DMSurfaceMap\[Mu]m, ColorFunction-> GrayLevel, Frame -> None]
ArrayPlot[DMMaskMap, ColorFunction\[Rule] GrayLevel, Frame \[Rule] None]*)


(* ::Section:: *)
(*Full pupil generation*)


(* ::Subsection:: *)
(*Clear aperture*)


(* ::Text:: *)
(*Generation of a clear aperture. Used for the computation of core throughput defined by J. Krist *)


ClearAperture=Cr\[EAcute]eDiaphragmeCenter[nPup/2., nPup];
ArrayPlot[ClearAperture,  ColorFunction -> GrayLevel, PlotRange -> All, Frame-> False]


(* ::Subsection:: *)
(*Aperture*)


(* ::Text:: *)
(*Full generation and display of the aperture*)


Aperture=If[FullKeyword==1,
AperturePartial,
If[QuarterKeyword==1,
FullPupilFromQuarterGenerationFunction[AperturePartial, nPup],
FullPupilFromHalfGenerationFunction[AperturePartial, nPup]]
];
(*ShapedAperture = AperturePartial*ProlatePreApod;
Aperture=If[ProlateKeyword==1,
ShapedAperture,PureAperture];*)

AperturePlot = ArrayPlot[Aperture, ColorFunction -> GrayLevel, Frame -> False]


(*Export["/Users/kstlaurent/Desktop/AperturePreApod_Gaussian010_Rescale050.pdf",AperturePlot]*)


(* ::Subsection:: *)
(*Shaped pupil*)


(* ::Subsubsection:: *)
(*Full pupil generation*)


(* ::Text:: *)
(*Full shaped pupil generation*)


ShapedPupil=If[FullKeyword==1,
MultFactor*ShapedPupilPartial,
If[QuarterKeyword==1,
FullPupilFromQuarterGenerationFunction[ShapedPupilPartial, nPup],
FullPupilFromHalfGenerationFunction[ShapedPupilPartial, nPup]]
];

ShapedPupilPDF = ArrayPlot[ShapedPupil, ColorFunction -> GrayLevel, Frame -> False]


(* ::Input:: *)
(**)


(* ::Subsubsection:: *)
(*Binarity tests*)


(* ::Text:: *)
(*Comparison between shaped pupil and its rounded version*)


ShapedPupilWithPupil=ShapedPupil*Aperture;
RoundShapedPupilWithPupil=Round[ShapedPupilWithPupil];
DiffShapedPupilWithPupil=Abs[ShapedPupilWithPupil-RoundShapedPupilWithPupil];
ApodizerPDF = ArrayPlot[ShapedPupilWithPupil,  ColorFunction -> "GrayTones", Frame-> False]
ArrayPlot[DiffShapedPupilWithPupil,  ColorFunction -> GrayLevel, Frame -> False]


(* ::Subsection:: *)
(*Lyot stop*)


(* ::Subsubsection:: *)
(*Full Lyot Stop generation*)


(* ::Text:: *)
(*Full generation and display of the Lyot stop*)


LyotStop=If[FullKeyword==1,
LyotStopPartial,
If[QuarterKeyword==1,
FullPupilFromQuarterGenerationFunction[LyotStopPartial, nPup],
FullPupilFromHalfGenerationFunction[LyotStopPartial, nPup]]
];
ArrayPlot[LyotStop, ColorFunction -> GrayLevel, Frame -> False]


(* ::Subsection:: *)
(*Generation of shifted Lyot stop*)


(* ::Subsubsection:: *)
(*Array of shifted Lyot stops*)


(* ::Text:: *)
(*Array of shifted Lyot stops *)


ResizeLyotStopSpiders=Resize[LyotStop, nPupForLyotStopShift];
ResizedShiftedLyotStopArray=Table[0., {nShift},{nPupForLyotStopShift}, {nPupForLyotStopShift}];


If[YaxisShiftKeyword==1,
Do[
ResizedShiftedLyotStopArray[[iShift, All,All]]=ShiftImageInterp[ResizeLyotStopSpiders, ((nShift +1)/2 -iShift)*ShiftStep, 0.] ;
ResizedShiftedLyotStopArray[[nShift -iShift+1, All,All]]= Reverse[ResizedShiftedLyotStopArray[[iShift, All,All]],1];
,{iShift,1, (nShift+1)/2-1}];
ResizedShiftedLyotStopArray[[(nShift+1)/2, All,All]]=ResizeLyotStopSpiders,
Do[
ResizedShiftedLyotStopArray[[iShift, All,All]]=ShiftImageInterp[ResizeLyotStopSpiders, 0.,((nShift +1)/2 -iShift)*ShiftStep];
ResizedShiftedLyotStopArray[[nShift -iShift+1, All,All]]= Reverse[ResizedShiftedLyotStopArray[[iShift, All,All]], 2];
,{iShift,1, (nShift+1)/2-1}];
ResizedShiftedLyotStopArray[[(nShift+1)/2, All,All]]=ResizeLyotStopSpiders;
];


(* ::Text:: *)
(*Array of differences between shifted and centered Lyot stops*)


DifferenceResizedShiftedLyotStopArray=Table[ResizedShiftedLyotStopArray[[iShift]]-ResizedShiftedLyotStopArray[[(nShift+1)/2]], {iShift, 1, nShift}];


(* ::Subsubsection:: *)
(*Display*)


iShift0=1.;
ArrayPlot[ResizedShiftedLyotStopArray[[iShift0]]]
If[nShift >=3,
iShift0=5;
ArrayPlot[DifferenceResizedShiftedLyotStopArray[[iShift0]], ColorFunction-> GrayLevel, Frame-> False]
];


(* ::Section::Closed:: *)
(*DM shape - processing*)


(* ::Subsection::Closed:: *)
(*Dimensions*)


(* ::Text:: *)
(*Radius, diameter, and area of the numerical mask for the DM*)


AreaDMMask=Total[DMMaskMap,2];
RadiusDMMask=Sqrt[AreaDMMask/\[Pi]]//N;
DiameterDMMask=2.*RadiusDMMask;



(* ::Text:: *)
(*Beam size on the DM actuators*)


SubDiameterDMMask=nActUsed/nAct DiameterDMMask;



(* ::Text:: *)
(*Array size of the used DM actuators*)


nDMMapUsed=If[EvenQ[Round[SubDiameterDMMask]], Round[SubDiameterDMMask], Round[SubDiameterDMMask]-1];


(* ::Subsection::Closed:: *)
(*Statistics*)


(* ::Text:: *)
(*Position of the pts inside the numerical mask*)


DMMaskMapPts=Position[DMMaskMap,1];
Dimensions[DMMaskMapPts];


(* ::Text:: *)
(*Mean and sigma for the DM phase map in nm and nm rms*)


nmWFEmeanInitial=Mean[Extract[DMSurfaceMap\[Mu]m,DMMaskMapPts]]*\[Mu]m/nm;
nmWFErmsInitial = StandardDeviation[Extract[DMSurfaceMap\[Mu]m,DMMaskMapPts]]*\[Mu]m/nm;


(* ::Subsection:: *)
(*Operations on map*)


(* ::Subsubsection::Closed:: *)
(*Cropped DM map*)


(* ::Text:: *)
(*Cropped of the DM map down to the beam size on the DM*)


CropDMSurfaceMap1\[Mu]m = DMSurfaceMap\[Mu]m[[nDMMap/2 - nDMMapUsed/2 ;; nDMMap/2 + nDMMapUsed/2 - 1, nDMMap/2 - nDMMapUsed/2 ;; nDMMap/2 + nDMMapUsed/2 - 1]]*Cr\[EAcute]eDiaphragmeCenter[nDMMapUsed/2, nDMMapUsed];


(*ArrayPlot[CropDMSurfaceMap1\[Mu]m, ColorFunction -> GrayLevel, Frame -> None]*)


(* ::Subsubsection::Closed:: *)
(*Statistics*)


(* ::Text:: *)
(*Position of the pts inside the numerical mask*)


PupilTest=Cr\[EAcute]eDiaphragmeCenter[nDMMapUsed/2, nDMMapUsed];
PupilTestPts=Position[PupilTest, 1.];


(* ::Text:: *)
(*Mean and sigma for the DM used map in nm and nm rms*)


Mean[Extract[CropDMSurfaceMap1\[Mu]m, PupilTestPts]]*\[Mu]m/nm;
StandardDeviation[Extract[CropDMSurfaceMap1\[Mu]m, PupilTestPts]]*\[Mu]m/nm;


(* ::Subsubsection::Closed:: *)
(*Set mean map value to 0*)


(* ::Text:: *)
(*Removal of the mean wavefront error in the map*)


CropDMSurfaceMap2\[Mu]m=Table[0., {nDMMapUsed}, {nDMMapUsed}];


MeanCropDMSurfaceMap1\[Mu]m=Mean[Extract[CropDMSurfaceMap1\[Mu]m, PupilTestPts]];
Do[
CropDMSurfaceMap2\[Mu]m[[PupilTestPts[[i,1]],PupilTestPts[[i,2]]]]=CropDMSurfaceMap1\[Mu]m[[PupilTestPts[[i,1]],PupilTestPts[[i,2]]]]-MeanCropDMSurfaceMap1\[Mu]m;

, {i, 1, Length[PupilTestPts]}];

Mean[Extract[CropDMSurfaceMap2\[Mu]m, PupilTestPts]]*\[Mu]m/nm;
MeasuredWFErms=StandardDeviation[Extract[CropDMSurfaceMap2\[Mu]m, PupilTestPts]]*1.\[Mu]m;
MeasuredWFErms/nm;


(* ::Subsubsection::Closed:: *)
(*Set nm rms WFE to the map *)


(* ::Text:: *)
(*Scaling of the rms Wavefront error of the map to the value set by the user*)


(*DMPhaseMapIntroducedrmsWFE=MeasuredWFErms;*)


CropDMSurfaceMap3\[Mu]m=(DMPhaseMapIntroducedrmsWFE/MeasuredWFErms)*CropDMSurfaceMap2\[Mu]m;
StandardDeviation[Extract[CropDMSurfaceMap3\[Mu]m, PupilTestPts]]*\[Mu]m/nm;


(* ::Subsubsection::Closed:: *)
(*Display*)


(*Print[Legended[
ArrayPlot[CropDMSurfaceMap2\[Mu]m*1000., ColorFunction -> "Rainbow", Frame -> False,PlotRange-> {-60., 60.}],
 BarLegend[{"Rainbow", {-60., 60.}},(* LegendLabel \[Rule] Style["Contrast in \n log scale", TextAlignment \[Rule] Center],*) LegendMargins->10,  LegendMarkerSize -> 375, LabelStyle->Directive[FontFamily->"Helvetica", FontSize -> 20.]]
]
]*)



(* ::Subsubsection::Closed:: *)
(*Resizing of the map using FFTs *)


(* ::Text:: *)
(*Dimensions of the padded maps*)


nDMMapUsedPadded = nDMMapUsed*DMPhaseMapZeroPaddingFactor;
nPupPadded=nPup*DMPhaseMapZeroPaddingFactor;


(* ::Text:: *)
(*Resizing of the maps using FFT*)


ResizeCropDMSurfaceMap\[Mu]m = Resize[CropDMSurfaceMap3\[Mu]m, nDMMapUsedPadded];
FFTImage=FFT[ResizeCropDMSurfaceMap\[Mu]m];
ZeroPadFFTImage=Resize[FFTImage, nPupPadded];
IFFTZeroPadFFTImage=IFFT[ZeroPadFFTImage];
ResizeDMSurfaceMap\[Mu]m=(nPup/nDMMapUsed)*Re[IFFTZeroPadFFTImage[[nPupPadded/2-nPup/2;;nPupPadded/2+nPup/2-1, nPupPadded/2-nPup/2;;nPupPadded/2+nPup/2-1]]];


(* ::Text:: *)
(*Display of the map*)


(*ArrayPlot[ResizeCropDMSurfaceMap\[Mu]m, ColorFunction -> GrayLevel, Frame -> None]*)


(* ::Subsubsection::Closed:: *)
(*Removal of the low-spatial frequencies using Hann window filter*)


(* ::Text:: *)
(*Cutoff frequency of the Hann window*)


CutOff=4.*nActUsed*nImg2D/nFmax2D*1/(UndersizedPup*LyotStopShiftResizingFactor);


(* ::Text:: *)
(*Definition of the Hann window (be careful, computation is long depending on the size of the DM phase padded arrays - ~1min for a 1500x1500 size array)*)


HannWindowFilter=If[HannKeyword==1,
Table[HannWindow[Sqrt[(i-nDMMapUsedPadded/2.)^2+ (j-nDMMapUsedPadded/2.)^2]/CutOff], {i, 1, nDMMapUsedPadded}, {j, 1, nDMMapUsedPadded}],
Table[0., {nDMMapUsedPadded}, {nDMMapUsedPadded}]];


(* ::Text:: *)
(*Display of the Hann window*)


(*ArrayPlot[HannWindowFilter^0.25, ColorFunction -> GrayLevel]*)


(* ::Text:: *)
(*Filtering of the map via FFT using HannWindowFilter, Removal of the low spatial frequencies, Display of the filtering*)


If[HannKeyword==1,
FFTImageBis=FFTImage*HannWindowFilter;
ZeroPadFFTImageBis=Resize[FFTImageBis, nPupPadded];
IFFTZeroPadFFTImageBis=IFFT[ZeroPadFFTImageBis];
ResizeDMSurfaceMap\[Mu]mBis=(nPup/nDMMapUsed)*Re[IFFTZeroPadFFTImageBis[[nPupPadded/2-nPup/2;;nPupPadded/2+nPup/2-1, nPupPadded/2-nPup/2;;nPupPadded/2+nPup/2-1]]];
HighPassResizeDMSurfaceMap\[Mu]m=ResizeDMSurfaceMap\[Mu]mBis-ResizeDMSurfaceMap\[Mu]m;
Print[ArrayPlot[HighPassResizeDMSurfaceMap\[Mu]m, ColorFunction -> GrayLevel, Frame -> None]];,
HighPassResizeDMSurfaceMap\[Mu]m=ResizeDMSurfaceMap\[Mu]m;
]


(* ::Subsubsection::Closed:: *)
(*Statistics*)


(* ::Text:: *)
(*Position of the points inside the clear aperture, mean and sigma of the highly passed filtered DM phase map*)


ClearAperturePts=Position[ClearAperture, 1.];
nmWFEmean=Mean[Extract[HighPassResizeDMSurfaceMap\[Mu]m, ClearAperturePts]]*\[Mu]m/nm;
nmWFErms=StandardDeviation[Extract[HighPassResizeDMSurfaceMap\[Mu]m, ClearAperturePts]]*\[Mu]m/nm;


Dimensions[Aperture];
Dimensions[HighPassResizeDMSurfaceMap\[Mu]m];


(* ::Subsubsection:: *)
(*PSD - TBC*)


(* ::Text:: *)
(*Plotting of the PSD*)


SFmaxPSD=100.;


(* ::Text:: *)
(*PSD computation - careful, PSD does not seem to be properly normalized*)


PSD=(1./(\[Pi] nPup^2/4))*Abs[ \[Mu]m*SFT[HighPassResizeDMSurfaceMap\[Mu]m, SFmaxPSD, nPup, Centering -> "Pixel"]]^2;
(*PSDBis=Abs[ZeroPadFFTImage]^2;*)


(* ::Text:: *)
(*Use of DM map aberration amount to try to normalize the PSD*)


aa=Sqrt[Total[PSD, 2]];
PSDNorm=(nmWFErms^2*nm^2/aa^2)PSD;


(* ::Text:: *)
(*Azimuthal average of the PSD map*)


AzimuthalAveragePSDNorm=AzimuthalAverage[PSDNorm];
Dimensions[AzimuthalAveragePSDNorm];


(* ::Text:: *)
(*PSD display*)


ArrayPlot[PSDNorm^0.25, ColorFunction -> GrayLevel, Frame -> None]


(* ::Subsubsection:: *)
(*Plot of the PSD*)


XiPSD = Table[k*SFmaxPSD/nPup,{k,0,nPup}];


PreListPlot=Table[{XiPSD[[k]], Log10[10^12*AzimuthalAveragePSDNorm[[k]]]}, {k,1,nPup/2}];


ListPlot[PreListPlot,Joined->True, PlotRange-> {{-0.5,50.5}, {-1.8, -12.2}}, 
ImageSize-> Large,
LabelStyle->Directive[FontFamily->"Helvetica", FontSize-> 15.], 
 FrameLabel-> {"Spatial frequency in cycles/pup", "PSD in log scale"},
FrameStyle-> AbsoluteThickness[1.1],
PlotStyle->Table[Directive[ColorData["Rainbow",i/(Length[PreListPlot]-1)], AbsoluteThickness[2.0]],{i,0,Length[PreListPlot]-1}],
Epilog ->{FontSize -> 15.,AbsoluteThickness[2.0],{Dashed,Blue, Line[{{{\[Rho]0, 0}, {\[Rho]0, -20}}, {{\[Rho]1, 0}, {\[Rho]1, -20}}}]}, 
{Dotted, Red, Line[{{MMaskProj, 0}, {MMaskProj, -20}}]}, 
{Black, Line[{{\[Rho]0,Log10[cDarkHoleRegion]},{\[Rho]1,Log10[cDarkHoleRegion]}}]},
{Black,  Line[{{0.,Log10[cCoreRegion]},{\[Rho]0,Log10[cCoreRegion]}}]},
{Black,  Line[{{\[Rho]0,Log10[cSecondaryRegion]},{50.,Log10[cSecondaryRegion]}}]},
{Inset[Style["m/2=" <>ToString[PaddedForm[MMaskProj, {3, 2}]] <>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Red, FontFamily -> "Helvetica"],  {MMaskProj+ 5.5, -2.5}] },
{Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(i\)]\)=" <> ToString[PaddedForm[\[Rho]0, {2, 1}]]<>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Blue, FontFamily -> "Helvetica"],  {\[Rho]0+4.5, -3.5}] },
{Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(o\)]\)=" <> ToString[PaddedForm[\[Rho]1, {2, 1}]]<>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Blue, FontFamily -> "Helvetica"],  {\[Rho]1+4.5 ,-4.5}] }

}]


(* ::Chapter:: *)
(*Resize with error diffusion algorithm*)


(* ::Subsection::Closed:: *)
(*Increase size array*)


(* ::Subsubsection:: *)
(*Pupil size increase for apertures and Lyot stop*)


(* ::Text:: *)
(*Resizing of the different pupil arrays*)


If[ResizingFactor==1,
SuperClearAperture=ClearAperture;
SuperAperture=Aperture;
SuperLyotStop=LyotStop;,
SuperClearAperture=SizeIncrease[ClearAperture, ResizingFactor];
SuperAperture=SizeIncrease[Aperture, ResizingFactor];
SuperLyotStop=SizeIncrease[LyotStop, ResizingFactor];
]


(* ::Subsubsection:: *)
(*Pupil size increase for the apodizer*)


(* ::Text:: *)
(*Resizing of the shaped pupil array and possible use of error diffusion algorithm*)


If[ResizingFactor==1,
SuperShapedPupil=If[RoundApodKeyword==1,Round[ShapedPupil],ShapedPupil];,
SuperShapedPupil=SizeIncreaseAndErrorDiffusion[ShapedPupil, ResizingFactor];
]


(* ::Subsubsection:: *)
(*Pupil size increase for the shifted Lyot stops*)


(* ::Text:: *)
(*Resizing of the shifted Lyot stop*)


If[ResizingFactor==1,
SuperResizedShiftedLyotStopArray=ResizedShiftedLyotStopArray;,
SuperResizedShiftedLyotStopArray=Table[0., {nShift}];
Do[
SuperResizedShiftedLyotStopArray[[iShift]]=SizeIncrease[ResizedShiftedLyotStopArray[[iShift]], ResizingFactor];,
{iShift,1, nShift}];
]


(* ::Subsection::Closed:: *)
(*Clear All the original arrays*)


If[ResizingFactor!= 1 && KeywordExportFitsFiles != 1,
ClearAll[ClearAperture];
(*ClearAll[Aperture];
ClearAll[LyotStop];*)
ClearAll[ShapedPupil];
ClearAll[ResizedShiftedLyotStopArray];
]


(* ::Subsection::Closed:: *)
(*Oversized pupils*)


If[nPupForLyotStopShift != nPup,
nPupHyper=nPupForLyotStopShift*ResizingFactor;
HyperClearAperture=Resize[SuperClearAperture, nPupHyper];
HyperAperture=Resize[SuperAperture, nPupHyper];
HyperShapedPupil=Resize[SuperShapedPupil, nPupHyper];,
nPupHyper=nPupForLyotStopShift;
HyperClearAperture=SuperClearAperture;
HyperAperture=SuperAperture;
HyperShapedPupil=SuperShapedPupil;
]


(* ::Subsection::Closed:: *)
(*DM phase*)


(* ::Text:: *)
(*Computation of phasor terms*)


DMPhasorTable=Table[0.,{i\[Lambda], 1, n\[Lambda]}];


Do[
\[Lambda]=\[Lambda]Table[[i\[Lambda]]];
If[nPupForLyotStopShift != nPup,
nPupHyper=nPupForLyotStopShift*ResizingFactor;
DMPhasorTable[[i\[Lambda]]]=Exp[2.\[Pi] I (Resize[HighPassResizeDMSurfaceMap\[Mu]m, nPupHyper]*\[Mu]m)/\[Lambda]HiCAT*(\[Lambda]0/\[Lambda])];,
nPupHyper=nPupForLyotStopShift;
DMPhasorTable[[i\[Lambda]]]=Exp[2.\[Pi] I (HighPassResizeDMSurfaceMap\[Mu]m*\[Mu]m)/\[Lambda]HiCAT*(\[Lambda]0/\[Lambda])];]
,{i\[Lambda], 1, n\[Lambda]}];


(*MemoryInUse[]*)


(* ::Chapter:: *)
(*APLC SP propagation*)


(* ::Section::Closed:: *)
(*Lyot plane*)


(* ::Subsubsection:: *)
(*Lyot plane field, before stop application*)


BeforeLyotFieldLP2DCAAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];
BeforeLyotFieldLP2D00All=Table[0., {i\[Lambda], 1, n\[Lambda]}];
BeforeLyotFieldLP2D0All=Table[0., {i\[Lambda], 1, n\[Lambda]}];
BeforeLyotFieldLP2D0DMAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];
BeforeLyotFieldLP2DAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];
BeforeLyotFieldLP2DDMAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];


Do[
\[Lambda]=\[Lambda]Table[[i\[Lambda]]];

BeforeLyotFieldLP2DCAAll[[i\[Lambda]]]=ToLyotPlaneCenter[HyperClearAperture, 0., Wavelength-> \[Lambda]/\[Lambda]0, OverSizePupil->LyotStopShiftResizingFactor, MaskSampling -> MaskSampling0];
BeforeLyotFieldLP2D00All[[i\[Lambda]]]=ToLyotPlaneCenter[HyperAperture, 0., Wavelength-> \[Lambda]/\[Lambda]0, OverSizePupil->LyotStopShiftResizingFactor, MaskSampling -> MaskSampling0];
BeforeLyotFieldLP2D0All[[i\[Lambda]]]=ToLyotPlaneCenter[HyperShapedPupil*HyperAperture, 0., Wavelength-> \[Lambda]/\[Lambda]0, OverSizePupil->LyotStopShiftResizingFactor, MaskSampling -> MaskSampling0];
BeforeLyotFieldLP2D0DMAll[[i\[Lambda]]]=ToLyotPlaneCenter[HyperShapedPupil*HyperAperture*DMPhasorTable[[i\[Lambda]]], 0., Wavelength-> \[Lambda]/\[Lambda]0, OverSizePupil->LyotStopShiftResizingFactor, MaskSampling -> MaskSampling0];
BeforeLyotFieldLP2DAll[[i\[Lambda]]]=ToLyotPlaneCenter[HyperShapedPupil*HyperAperture, 2.*MMask, Wavelength-> \[Lambda]/\[Lambda]0, OverSizePupil->LyotStopShiftResizingFactor, MaskSampling -> MaskSampling0];
BeforeLyotFieldLP2DDMAll[[i\[Lambda]]]=ToLyotPlaneCenter[HyperShapedPupil*HyperAperture*DMPhasorTable[[i\[Lambda]]], 2.*MMask, Wavelength-> \[Lambda]/\[Lambda]0, OverSizePupil->LyotStopShiftResizingFactor];
;
,{i\[Lambda], 1, n\[Lambda]}];



MaskSampling0


(* ::Subsubsection:: *)
(*Lyot plane field, after stop application*)


LyotFieldLP2DCAAllTable=Table[0., {iShift, 1, nShift}];
LyotFieldLP2D00AllTable=Table[0., {iShift, 1, nShift}];
LyotFieldLP2D0AllTable=Table[0., {iShift, 1, nShift}];
LyotFieldLP2D0DMAllTable=Table[0., {iShift, 1, nShift}];
LyotFieldLP2DAllTable=Table[0., {iShift, 1, nShift}];
LyotFieldLP2DDMAllTable=Table[0.,{iShift, 1, nShift}];


Do[

LyotFieldLP2DCAAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];
LyotFieldLP2D00All=Table[0., {i\[Lambda], 1, n\[Lambda]}];
LyotFieldLP2D0All=Table[0., {i\[Lambda], 1, n\[Lambda]}];
LyotFieldLP2D0DMAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];
LyotFieldLP2DAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];
LyotFieldLP2DDMAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];

Do[

LyotFieldLP2DCAAll[[i\[Lambda]]]=BeforeLyotFieldLP2DCAAll[[i\[Lambda]]]*HyperClearAperture;
LyotFieldLP2D00All[[i\[Lambda]]]=BeforeLyotFieldLP2D00All[[i\[Lambda]]]*SuperResizedShiftedLyotStopArray[[iShift]];
LyotFieldLP2D0All[[i\[Lambda]]]=BeforeLyotFieldLP2D0All[[i\[Lambda]]]*SuperResizedShiftedLyotStopArray[[iShift]];
LyotFieldLP2D0DMAll[[i\[Lambda]]]=BeforeLyotFieldLP2D0DMAll[[i\[Lambda]]]*SuperResizedShiftedLyotStopArray[[iShift]];
LyotFieldLP2DAll[[i\[Lambda]]]=BeforeLyotFieldLP2DAll[[i\[Lambda]]]*SuperResizedShiftedLyotStopArray[[iShift]];
LyotFieldLP2DDMAll[[i\[Lambda]]]=BeforeLyotFieldLP2DDMAll[[i\[Lambda]]]*SuperResizedShiftedLyotStopArray[[iShift]];


,{i\[Lambda], 1, n\[Lambda]}];

LyotFieldLP2DCAAllTable[[iShift]]=LyotFieldLP2DCAAll;
LyotFieldLP2D00AllTable[[iShift]]=LyotFieldLP2D00All;
LyotFieldLP2D0AllTable[[iShift]]=LyotFieldLP2D0All;
LyotFieldLP2D0DMAllTable[[iShift]]=LyotFieldLP2D0DMAll;
LyotFieldLP2DAllTable[[iShift]]=LyotFieldLP2DAll;
LyotFieldLP2DDMAllTable[[iShift]]=LyotFieldLP2DDMAll;

, {iShift, 1, nShift}]


If[ResizingFactor!= 1,
Clear[BeforeLyotFieldLP2DCAAll];
Clear[BeforeLyotFieldLP2D00All];
Clear[BeforeLyotFieldLP2D0All];
Clear[BeforeLyotFieldLP2D0DMAll];
Clear[BeforeLyotFieldLP2DAll];
Clear[BeforeLyotFieldLP2DDMAll];
Clear[LyotFieldLP2DCAAll];
Clear[LyotFieldLP2D00All];
Clear[LyotFieldLP2D0All];
Clear[LyotFieldLP2D0DMAll];
Clear[LyotFieldLP2DAll];
Clear[LyotFieldLP2DDMAll];
]


MemoryInUse[]


Dimensions[BeforeLyotFieldLP2DAll]
Dimensions[LyotFieldLP2DAllTable]


(* ::Subsection::Closed:: *)
(*Display*)


(* ::Subsubsection:: *)
(*Without DM*)


i\[Lambda]0 = (n\[Lambda] + 1)/2;
If[ResizingFactor ==  1,
 PreArrayPlot = Abs[BeforeLyotFieldLP2DAll[[i\[Lambda]0, All, All]]]^0.5;
 PupilPlaneArrayPlot[PreArrayPlot]
 ]



i\[Lambda]0 = (n\[Lambda] + 1)/2;
If[ResizingFactor ==  1,
 PreArrayPlot = Abs[LyotFieldLP2DAllTable[[(nShift + 1)/2, i\[Lambda]0, All, All]]]^0.5;
 PupilPlaneArrayPlot[PreArrayPlot]
 ]


If[ResizingFactor ==  1,
 If[nShift > 1,
  PreArrayPlot = Abs[LyotFieldLP2DAllTable[[(nShift + 1)/2 + 1, (n\[Lambda] + 1)/2, All, All]]]^0.5;
  PupilPlaneArrayPlot[PreArrayPlot]
  ]
 ]


If[ResizingFactor ==  1,
 If[nShift > 2,
  PreArrayPlot = Abs[LyotFieldLP2DAllTable[[(nShift + 1)/2 + 2, (n\[Lambda] + 1)/2, All, All]]]^0.5;
  PupilPlaneArrayPlot[PreArrayPlot]
  ]
 ]


If[ResizingFactor ==  1,
 If[nShift > 3,
  PreArrayPlot = Abs[LyotFieldLP2DAllTable[[(nShift + 1)/2, (n\[Lambda] + 1)/2, All, All]]]^0.5;
  PupilPlaneArrayPlot[PreArrayPlot]
  ]
 ]


Dimensions[LyotFieldLP2DAllTable];


(* ::Subsubsection::Closed:: *)
(*With DM*)


(* ::Text:: *)
(*If[ResizingFactor ==  1,*)
(* i\[Lambda]0 = (n\[Lambda] + 1)/2;*)
(* PreArrayPlot = Abs[BeforeLyotFieldLP2DDMAll[[i\[Lambda]0, All, All]]^0.5];*)
(* PupilPlaneArrayPlot[PreArrayPlot]*)
(* ]*)


(* ::Section::Closed:: *)
(*Camera plane*)


(* ::Subsection:: *)
(*Final image plane field*)


FinalFieldLP2DCAAllTable=Table[0., {iShift, 1, nShift}];
FinalFieldLP2D00AllTable=Table[0., {iShift, 1, nShift}];
FinalFieldLP2D0AllTable=Table[0., {iShift, 1, nShift}];
FinalFieldLP2D0DMAllTable=Table[0., {iShift, 1, nShift}];
FinalFieldLP2DAllTable=Table[0., {iShift, 1, nShift}];
FinalFieldLP2DDMAllTable=Table[0.,{iShift, 1, nShift}];



Do[

FinalFieldLP2DCAAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];
FinalFieldLP2D00All=Table[0., {i\[Lambda], 1, n\[Lambda]}];
FinalFieldLP2D0All=Table[0., {i\[Lambda], 1, n\[Lambda]}];
FinalFieldLP2D0DMAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];
FinalFieldLP2DAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];
FinalFieldLP2DDMAll=Table[0., {i\[Lambda], 1, n\[Lambda]}];

Do[

\[Lambda]=\[Lambda]Table[[i\[Lambda]]];

FinalFieldLP2DCAAll[[i\[Lambda]]]=(\[Lambda]0/\[Lambda])*SFT[LyotFieldLP2D00AllTable[[iShift]][[i\[Lambda]]],nFmax2D*(\[Lambda]0/\[Lambda])*UndersizedPup*LyotStopShiftResizingFactor ,nImg2D, Centering -> "Pixel"];
FinalFieldLP2D00All[[i\[Lambda]]]=(\[Lambda]0/\[Lambda])*SFT[LyotFieldLP2D00AllTable[[iShift]][[i\[Lambda]]],nFmax2D*(\[Lambda]0/\[Lambda])*UndersizedPup*LyotStopShiftResizingFactor ,nImg2D, Centering -> "Pixel"];
FinalFieldLP2D0All[[i\[Lambda]]]=(\[Lambda]0/\[Lambda])*SFT[LyotFieldLP2D0AllTable[[iShift]][[i\[Lambda]]],nFmax2D*(\[Lambda]0/\[Lambda])*UndersizedPup*LyotStopShiftResizingFactor ,nImg2D, Centering -> "Pixel"];
FinalFieldLP2D0DMAll[[i\[Lambda]]]=(\[Lambda]0/\[Lambda])*SFT[LyotFieldLP2D0DMAllTable[[iShift]][[i\[Lambda]]], nFmax2D*(\[Lambda]0/\[Lambda])*UndersizedPup*LyotStopShiftResizingFactor ,nImg2D, Centering -> "Pixel"];
FinalFieldLP2DAll[[i\[Lambda]]]=(\[Lambda]0/\[Lambda])*SFT[LyotFieldLP2DAllTable[[iShift]][[i\[Lambda]]], nFmax2D*(\[Lambda]0/\[Lambda])*UndersizedPup*LyotStopShiftResizingFactor ,nImg2D, Centering -> "Pixel"];
FinalFieldLP2DDMAll[[i\[Lambda]]]=(\[Lambda]0/\[Lambda])*SFT[LyotFieldLP2DDMAllTable[[iShift]][[i\[Lambda]]], nFmax2D*(\[Lambda]0/\[Lambda])*UndersizedPup*LyotStopShiftResizingFactor ,nImg2D, Centering -> "Pixel"];

,{i\[Lambda], 1, n\[Lambda]}];

FinalFieldLP2DCAAllTable[[iShift]]=FinalFieldLP2DCAAll;
FinalFieldLP2D00AllTable[[ iShift]]=FinalFieldLP2D00All;
FinalFieldLP2D0AllTable[[ iShift]]=FinalFieldLP2D0All;
FinalFieldLP2D0DMAllTable[[ iShift]]=FinalFieldLP2D0DMAll;
FinalFieldLP2DAllTable[[ iShift]]=FinalFieldLP2DAll;
FinalFieldLP2DDMAllTable[[iShift]]=FinalFieldLP2DDMAll;

, {iShift, 1, nShift}]



If[ResizingFactor !=  1,
Clear[LyotFieldLP2DCAAllTable];
Clear[LyotFieldLP2D00AllTable];
Clear[LyotFieldLP2D0AllTable];
Clear[LyotFieldLP2D0DMAllTable];
Clear[LyotFieldLP2DAllTable];
Clear[LyotFieldLP2DDMAllTable];
Clear[FinalFieldLP2DCAAll];
Clear[FinalFieldLP2D00All];
Clear[FinalFieldLP2D0All];
Clear[FinalFieldLP2D0DMAll];
Clear[FinalFieldLP2DAll];
Clear[FinalFieldLP2DDMAll];
]



(* ::Subsection:: *)
(*Computation of images*)


(* ::Subsubsection:: *)
(*Monochromatic images*)


FinalImageLP2DCAAllTable=Abs[FinalFieldLP2DCAAllTable]^2;
FinalImageLP2D00AllTable=Abs[FinalFieldLP2D00AllTable]^2;
FinalImageLP2D0AllTable=Abs[FinalFieldLP2D0AllTable]^2;
FinalImageLP2D0DMAllTable=Abs[FinalFieldLP2D0DMAllTable]^2;
FinalCoronoLP2DAllTable=Abs[FinalFieldLP2DAllTable]^2;
FinalCoronoLP2DDMAllTable=Abs[FinalFieldLP2DDMAllTable]^2;
FinalCoronoLP2DAberrAll=Abs[FinalFieldLP2DAberrAll]^2;
FinalImageLP2D0All=Abs[FinalFieldLP2D0All]^2;


Dimensions[FinalCoronoLP2DAllTable];


MemoryInUse[];


If[ResizingFactor !=  1,
Clear[FinalFieldLP2DCAAllTable];
Clear[FinalFieldLP2D00AllTable];
Clear[FinalFieldLP2D0AllTable];
Clear[FinalFieldLP2D0DMAllTable];
Clear[FinalFieldLP2DAllTable];
Clear[FinalFieldLP2DDMAllTable];
]


(* ::Subsubsection:: *)
(*Broadband images*)


Dimensions[FinalImageLP2D0AllTable];


PolyImagePSFLP2DCATable=Total[FinalImageLP2DCAAllTable, {2}];
PolyImagePSFLP2D00Table=Total[FinalImageLP2D00AllTable, {2}];
PolyImagePSFLP2D0Table=Total[FinalImageLP2D0AllTable, {2}];
PolyImagePSFLP2D0DMTable=Total[FinalImageLP2D0DMAllTable, {2}];
PolyCoronoPSFLP2DTable=Total[FinalCoronoLP2DAllTable, {2}];
PolyCoronoPSFLP2DDMTable=Total[FinalCoronoLP2DDMAllTable, {2}];
PolyCoronoPSFLP2DAberr=Total[FinalCoronoLP2DAberrAll, {3}];
PolyImagePSFLP2D0=Total[FinalImageLP2D0All, {1}];


Dimensions[PolyCoronoPSFLP2DTable];


(* ::Subsubsection:: *)
(*Normalization for monochromatic images*)


MonoImageArray=Table[0., {nShift}];
MonoImageDMArray=Table[0., {nShift}];
MonoCoronoImageArray=Table[0., {nShift}];
MonoCoronoDMImageArray=Table[0., {nShift}];


Do[
MonoImageArray[[iShift ]]=FinalImageLP2D0AllTable[[iShift, (n\[Lambda]+1)/2]]/FinalImageLP2D0AllTable[[iShift,(n\[Lambda]+1)/2, nImg2D/2+1, nImg2D/2+1]];
MonoImageDMArray[[iShift ]]=FinalImageLP2D0DMAllTable[[iShift, (n\[Lambda]+1)/2]]/FinalImageLP2D0AllTable[[iShift,(n\[Lambda]+1)/2, nImg2D/2+1, nImg2D/2+1]];
MonoCoronoImageArray[[iShift ]]=FinalCoronoLP2DAllTable[[iShift, (n\[Lambda]+1)/2]]/FinalImageLP2D0AllTable[[iShift,(n\[Lambda]+1)/2, nImg2D/2+1, nImg2D/2+1]];
MonoCoronoDMImageArray[[iShift ]]=FinalCoronoLP2DDMAllTable[[iShift, (n\[Lambda]+1)/2]]/FinalImageLP2D0AllTable[[iShift,(n\[Lambda]+1)/2, nImg2D/2+1, nImg2D/2+1]];
, {iShift, 1, nShift}]


Dimensions[MonoCoronoImageArray];


(* ::Subsubsection:: *)
(*Normalization for broadband images*)


PolyImagePSFLP2DCANTable=Table[0., {nShift}];
PolyImagePSFLP2D00NTable=Table[0.,{nShift}];
PolyImagePSFLP2D0NTable=Table[0., {nShift}];
PolyImagePSFLP2D0DMNTable=Table[0., {nShift}];
PolyCoronoPSFLP2DNTable=Table[0., {nShift}];
PolyCoronoPSFLP2DDMNTable=Table[0., {nShift}];


Do[
PolyImagePSFLP2DCANTable[[iShift]]=PolyImagePSFLP2DCATable[[ iShift]]/PolyImagePSFLP2D0Table[[iShift, nImg2D/2+1, nImg2D/2+1]];
PolyImagePSFLP2D00NTable[[iShift]]=PolyImagePSFLP2D00Table[[iShift]]/PolyImagePSFLP2D0Table[[iShift, nImg2D/2+1, nImg2D/2+1]];
PolyImagePSFLP2D0NTable[[iShift]]=PolyImagePSFLP2D0Table[[iShift]]/PolyImagePSFLP2D0Table[[iShift, nImg2D/2+1, nImg2D/2+1]];
PolyImagePSFLP2D0DMNTable[[iShift]]=PolyImagePSFLP2D0DMTable[[iShift]]/PolyImagePSFLP2D0Table[[iShift, nImg2D/2+1, nImg2D/2+1]];
PolyCoronoPSFLP2DNTable[[iShift]]=PolyCoronoPSFLP2DTable[[iShift]]/PolyImagePSFLP2D0Table[[iShift, nImg2D/2+1, nImg2D/2+1]];
PolyCoronoPSFLP2DDMNTable[[iShift]]=PolyCoronoPSFLP2DDMTable[[iShift]]/PolyImagePSFLP2D0Table[[ iShift, nImg2D/2+1, nImg2D/2+1]];

, {iShift, 1, nShift}];


Dimensions[PolyCoronoPSFLP2DNTable];


Max[PolyImagePSFLP2D0NTable];


(* ::Subsection::Closed:: *)
(*Display - Camera image in monochromatic light*)


(* ::Subsubsection::Closed:: *)
(*Performance without DM*)


(* ::Text:: *)
(*Coronagraphic image*)


(* ::Text:: *)
(*iShift0 = (nShift + 1)/2;*)
(*ImagePlaneArrayPlot[MonoCoronoImageArray[[iShift0]]];*)


(* ::Text:: *)
(*Max[PolyImagePSFLP2D0NTable]*)


(* ::Subsubsection::Closed:: *)
(*Performance with DM*)


(* ::Text:: *)
(*Direct image*)


(* ::Text:: *)
(*iShift0 = (nShift + 1)/2;*)
(*ImagePlaneArrayPlot[MonoImageDMArray[[iShift0]], -1, -10];*)
(*ImagePlaneArrayPlot[MonoCoronoDMImageArray[[iShift0]]];*)


(* ::Subsection:: *)
(*Display - Camera image in broadband light*)


(* ::Subsubsection:: *)
(*Performance without DM*)


(* ::Text:: *)
(*Non coronagraphic image - "Off-Axis PSF"*)


(*iShift0 = (nShift + 1)/2;
PSFOffAxis = ImagePlaneArrayPlot[PolyImagePSFLP2D0NTable[[iShift0]]]*)


(* ::Text:: *)
(*Coronagraphic image*)


iShift0=(nShift+1)/2+2;
PSF = ImagePlaneArrayPlot[PolyCoronoPSFLP2DNTable[[iShift0]]]


(* ::Subsubsection::Closed:: *)
(*Performance with DM*)


(* ::Text:: *)
(*iShift0 = (nShift + 1)/2;*)
(*ImagePlaneArrayPlot[PolyCoronoPSFLP2DDMNTable[[iShift0]]];*)


(* ::Text:: *)
(*Difference between coronagraphic images with and without DM*)


(* ::Text:: *)
(*iShift0 = (nShift + 1)/2;*)
(*ImagePlaneArrayPlot[Abs[PolyCoronoPSFLP2DDMNTable[[iShift0]] - PolyCoronoPSFLP2DNTable[[iShift0]]]];*)


(* ::Subsection::Closed:: *)
(*Satellite spot intensity*)


(* ::Text:: *)
(*nReselRadius0 = 4.;*)
(*xc0 = 0. + nActUsed*nImg2D/nFmax2D*1/(UndersizedPup*LyotStopShiftResizingFactor);*)
(*yc0 = 0.;*)
(*PhotometricApertureX = Cr\[EAcute]eDecenteredCirc[nReselRadius0*nImg2D/nFmax2D*1/(UndersizedPup*LyotStopShiftResizingFactor), nImg2D, xc0, yc0];*)
(*PhotometricApertureY = Cr\[EAcute]eDecenteredCirc[nReselRadius0*nImg2D/nFmax2D*1/(UndersizedPup*LyotStopShiftResizingFactor), nImg2D, yc0, xc0];*)
(*PhotometricApertureXY = Cr\[EAcute]eDecenteredCirc[nReselRadius0*nImg2D/nFmax2D*1/(UndersizedPup*LyotStopShiftResizingFactor), nImg2D, xc0, xc0];*)
(*PhotometricAperture = PhotometricApertureX + PhotometricApertureY + PhotometricApertureXY;*)
(*(*ArrayPlot[PhotometricAperture]*)*)


(* ::Text:: *)
(*iShift0 = (nShift + 1)/2;*)
(*ImagePlaneArrayPlot[PolyImagePSFLP2D0DMNTable[[iShift0]]*PhotometricAperture, -1, -10];*)


(* ::Text:: *)
(*PhotometricAperturePts = Position[PhotometricAperture, 1];*)
(*PhotometricApertureXPts = Position[PhotometricApertureX, 1];*)
(*PhotometricApertureYPts = Position[PhotometricApertureY, 1];*)
(*PhotometricApertureXYPts = Position[PhotometricApertureXY, 1];*)


(* ::Text:: *)
(*Max[Extract[MonoImageDMArray[[iShift0]], PhotometricAperturePts]];*)
(*Max[Extract[PolyImagePSFLP2D0DMNTable[[iShift0]], PhotometricAperturePts]];*)


(* ::Text:: *)
(*LateralSatellitePeak = Max[Extract[MonoImageDMArray[[iShift0]], PhotometricApertureYPts]];*)
(*Max[Extract[PolyImagePSFLP2D0DMNTable[[iShift0]], PhotometricApertureXPts]];*)


(* ::Text:: *)
(*Log10LateralSatellitePeak = Log10[LateralSatellitePeak];*)
(*Max[Extract[PolyImagePSFLP2D0DMNTable[[iShift0]], PhotometricApertureYPts]];*)


(* ::Text:: *)
(*DiagonalSatellitePeak = Max[Extract[MonoImageDMArray[[iShift0]], PhotometricApertureXYPts]] l*)


(* ::Text:: *)
(*Log10DiagonalSatellitePeak = Log10[DiagonalSatellitePeak];*)
(*Max[Extract[PolyImagePSFLP2D0DMNTable[[iShift0]], PhotometricApertureXYPts]];*)


(* ::Text:: *)
(*Log10[4.*LateralSatellitePeak + 4. DiagonalSatellitePeak];*)


(* ::Section:: *)
(*1D radial cut profiles*)


(* ::Subsection::Closed:: *)
(*Scale parameters*)


Xi = Table[k*nFmax/nImg*UndersizedPup,{k,0,nImg}];
Xi2D=Table[nFmax2D/nImg2D (k-nImg2D/2-1)*UndersizedPup,{k,1,nImg2D}];


PlotLabelPsfObs= (*If[IRISAOshape \[Equal] 1,"IRISAO, 15% central obstruction",*) (*ToString[Round[ratio*100]] <>*) "xx% central obstruction"(*]*);
PlotLabelPsfMono="";
PlotLabelPsfBw= ToString[Round[bandwidth*100]]<> "% bandwidth" ;
PlotLabelPsfMask="Mask radius m/2="  <>  ToString[MMask] <> "\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D" ;


(* ::Subsection:: *)
(*1D radial cut profile at Subscript[\[Lambda], 0] (no coronagraph)*)


(* ::Text:: *)
(*iShift0 = (nShift + 1)/2;*)
(*PreListPlot = {Table[{Xi2D[[k2D]], Log10[FinalImageLP2D00AllTable[[iShift0, (n\[Lambda] + 1)/2, nImg2D/2 + 1, k2D]]/FinalImageLP2D00AllTable[[iShift0, (n\[Lambda] + 1)/2, nImg2D/2 + 1, nImg2D/2 + 1]]]}, {k2D, 1, nImg2D}]};*)
(**)
(*ListPlot[PreListPlot, Joined -> True, PlotRange -> {{0, 16}, {0, -12}}, *)
(* ImageSize -> Large,*)
(* LabelStyle -> Directive[FontFamily -> "Helvetica", FontSize -> 15.], *)
(*  FrameLabel -> {"Angular separation in \!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", "Normalized intensity in log scale"},*)
(* FrameStyle -> AbsoluteThickness[1.1],*)
(* PlotStyle -> If[Length[PreListPlot] == 1, Directive[ColorData["Rainbow", 0], AbsoluteThickness[2.0]], Table[Directive[ColorData["Rainbow", i/(Length[PreListPlot] - 1)], AbsoluteThickness[2.0]], {i, 0, Length[PreListPlot] - 1}]], Epilog -> {FontSize -> 15., AbsoluteThickness[2.0], {Dashed, Blue, Line[{{{\[Rho]0, 0}, {\[Rho]0, -20}}, {{\[Rho]1, 0}, {\[Rho]1, -20}}}]}, {Dotted, Red, Line[{{MMaskProj, 0}, {MMaskProj, -20}}]}, *)
(*   {Black, Line[{{0., Log10[cDarkHoleRegion]}, {50., Log10[cDarkHoleRegion]}}]},*)
(*   {Gray, Line[{{0., Log10[cDarkHoleRegion] + 2}, {50., Log10[cDarkHoleRegion] + 2}}]},*)
(*   {Inset[Style[PlotLabelPsfObs, FontFamily -> "Helvetica"],  {22.5, -4.5}] },*)
(*   {Inset[Style[PlotLabelPsfBw, FontFamily -> "Helvetica"],  {22.5, -5}] },*)
(*   {Inset[Style[PlotLabelPsfMask, FontFamily -> "Helvetica"],  {22.5, -5.5}]}*)
(*   }]*)
(**)


(* ::Subsection:: *)
(*1D radial cut coronagraphic profile at Subscript[\[Lambda], 0] for different Lyot stop decentering - Monochromatic*)


(* ::Subsubsection::Closed:: *)
(*Without DM*)


(* ::Text:: *)
(*Direct images*)


(* ::Text:: *)
(*iShift0 = (nShift + 1)/2;*)
(*PreListPlot =*)
(*  Table[Table[{Xi2D[[k2D]], Log10[FinalImageLP2D0AllTable[[iShift, (n\[Lambda] + 1)/2, k2D, nImg2D/2 + 1]]/FinalImageLP2D0AllTable[[1, (n\[Lambda] + 1)/2, nImg2D/2 + 1, nImg2D/2 + 1]]]}, {k2D, 1, nImg2D}],*)
(*   {iShift, 1, nShift}];*)
(**)
(*ListPlot[PreListPlot, Joined -> True, PlotRange -> {{-0.5, 15}, {-1.8, -12.2}}, *)
(*          ImageSize -> Large, LabelStyle -> Directive[FontFamily -> "Helvetica", FontSize -> 15.], *)
(*          FrameLabel -> {"Angular separation in \!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", "Normalized intensity in log scale"},*)
(*          FrameStyle -> AbsoluteThickness[1.1],*)
(*          PlotStyle -> If[Length[PreListPlot] == 1, Directive[ColorData["Rainbow", 0], AbsoluteThickness[2.0]], Table[Directive[ColorData["Rainbow", i/(Length[PreListPlot] - 1)], AbsoluteThickness[2.0]], {i, 0, Length[PreListPlot] - 1}]],*)
(*          Epilog -> {FontSize -> 15., AbsoluteThickness[2.0], *)
(*                     {Dashed, Blue, Line[{{{PSF\[Rho]0, 0}, {PSF\[Rho]0, -20}}, {{PSF\[Rho]1, 0}, {PSF\[Rho]1, -20}}}]}, *)
(*                     {Dotted, Red, Line[{{MMaskProj, 0}, {MMaskProj, -20}}]}, *)
(*                     {Black, Line[{{PSF\[Rho]0, Log10[cPSFDarkHoleRegion]}, {PSF\[Rho]1, Log10[cPSFDarkHoleRegion]}}]},*)
(*                     {Black,  Line[{{PSF\[Rho]1, Log10[cPSFSecondaryRegion]}, {50., Log10[cPSFSecondaryRegion]}}]},*)
(*                     {Inset[Style["m/2=" <> ToString[PaddedForm[MMaskProj, {3, 2}]] <> "\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", Red, FontFamily -> "Helvetica"],  {MMaskProj + 5., -3.}] },*)
(*                     {Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(i\)]\)=" <> ToString[PaddedForm[PSF\[Rho]0, {2, 1}]] <> "\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", Blue, FontFamily -> "Helvetica"],  {PSF\[Rho]0 + 4., -2.5}] },*)
(*                     {Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(o\)]\)=" <> ToString[PaddedForm[PSF\[Rho]1, {2, 1}]] <> "\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", Blue, FontFamily -> "Helvetica"],  {PSF\[Rho]1 + 5, -2.5}] },*)
(*                     {Inset[Style[PlotLabelPsfBw, FontFamily -> "Helvetica"],  {40, -11}] }*)
(*                      }]*)


(* ::Text:: *)
(*Coronagraphic images*)


(* ::Text:: *)
(*iShift0 = (nShift + 1)/2;*)
(*PreListPlot =*)
(*    Table[Table[{Xi2D[[k2D]], Log10[FinalCoronoLP2DAllTable[[iShift, (n\[Lambda] + 1)/2, k2D, nImg2D/2 + 1]]/FinalImageLP2D0AllTable[[1, (n\[Lambda] + 1)/2, nImg2D/2 + 1, nImg2D/2 + 1]]]}, {k2D, 1, nImg2D}],*)
(*      {iShift, 1, nShift}];*)
(**)
(*ContrastListPlot[PreListPlot, MMaskProj, \[Rho]0, \[Rho]1, cCoreRegion, cSecondaryRegion, PlotLabelPsfMono, 15]*)
(**)
(**)


(* ::Subsubsection::Closed:: *)
(*With DM*)


(* ::Text:: *)
(*iShift0 = (nShift + 1)/2;*)
(*PreListPlot =*)
(*  Table[Table[{Xi2D[[k2D]], Log10[FinalCoronoLP2DDMAllTable[[iShift, (n\[Lambda] + 1)/2, k2D, nImg2D/2 + 1]]/FinalImageLP2D0AllTable[[1, (n\[Lambda] + 1)/2, nImg2D/2 + 1, nImg2D/2 + 1]]]}, {k2D, 1, nImg2D}],*)
(*   {iShift, 1, nShift}];*)
(**)
(*ContrastListPlot[PreListPlot, MMaskProj, \[Rho]0, \[Rho]1, cCoreRegion, cSecondaryRegion, PlotLabelPsfMono, 15];*)
(**)


(* ::Subsection:: *)
(*1D radial cut profiles for different Lyot stop decentering in broadband light*)


(* ::Subsubsection:: *)
(*without DM*)


(* ::Text:: *)
(*Non coronagraphic image*)


(*iShift0 = (nShift + 1)/2;
PreListPlot = Table[Table[{Xi2D[[k2D]], Log10[PolyImagePSFLP2D0NTable[[iShift, k2D, nImg2D/2 + 1]]]}, {k2D, 1, nImg2D}], {iShift, 1, nShift}];

RadialProfileOffAxis = ListPlot[PreListPlot, Joined -> True, PlotRange -> {{0, nFmax}, {0, -12.2}}, 
                                    ImageSize -> Large, LabelStyle -> Directive[FontFamily -> "Helvetica", FontSize -> 15.], 
                                    FrameLabel -> {"Angular separation in \!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", "Normalized intensity in log scale"},
                                    FrameStyle -> AbsoluteThickness[1.1],
                                    PlotStyle -> If[Length[PreListPlot] == 1, Directive[ColorData["Rainbow", 0], AbsoluteThickness[2.0]], Table[Directive[ColorData["Rainbow", i/(Length[PreListPlot] - 1)], AbsoluteThickness[2.0]], {i, 0, Length[PreListPlot] - 1}]],
                                    Epilog -> {FontSize -> 15., AbsoluteThickness[2.0], 
                                                 {Dashed, Blue, Line[{{{PSF\[Rho]0, 0}, {PSF\[Rho]0, -20}}, {{PSF\[Rho]1, 0}, {PSF\[Rho]1, -20}}}]}, 
                                                 {Dotted, Red, Line[{{MMaskProj, 0}, {MMaskProj, -20}}]}, 
                                                 {Black, Line[{{PSF\[Rho]0, Log10[cPSFDarkHoleRegion]}, {PSF\[Rho]1, Log10[cPSFDarkHoleRegion]}}]},
                                                 {Inset[Style["m/2=" <> ToString[PaddedForm[MMaskProj, {3, 2}]] <> "\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", Red, FontFamily -> "Helvetica"],  {MMaskProj + 1.5, -8.}] },
                                                 {Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(i\)]\)=" <> ToString[PaddedForm[PSF\[Rho]0, {2, 1}]] <> "\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", Blue, FontFamily -> "Helvetica"],  {PSF\[Rho]0 - 1.2, -10.5}] },
                                                 {Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(o\)]\)=" <> ToString[PaddedForm[PSF\[Rho]1, {2, 1}]] <> "\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", Blue, FontFamily -> "Helvetica"],  {PSF\[Rho]1 + 1.4, -10.5}] },
                                                 {Inset[Style[PlotLabelPsfBw, FontFamily -> "Helvetica"],  {40, -11}] }
                                                  }]*)


(* ::Text:: *)
(*Coronagraphic image*)


iShift0=(nShift+1)/2;

PreListPlot=Table[Table[{Xi2D[[k2D]],Log10[PolyCoronoPSFLP2DNTable[[iShift, k2D, nImg2D/2+1]]]}, {k2D, 1, nImg2D}], {iShift, 1, nShift}];

Length[PreListPlot]

RadialProfile = ListPlot[PreListPlot,Joined->True, PlotRange-> {{0,16}, {-2, -12.2}}, ImageSize-> Large,LabelStyle->Directive[FontFamily->"Helvetica", FontSize-> 15.], 
                         FrameLabel-> {"Angular separation in \!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D", "Normalized intensity in log scale"},
                         FrameStyle-> AbsoluteThickness[1.1],
                         PlotStyle->If[Length[PreListPlot] ==1, Directive[ColorData["Rainbow", 0],AbsoluteThickness[2.0]], Table[Directive[ColorData["Rainbow",i/(Length[PreListPlot]-1)], AbsoluteThickness[2.0]],{i,0,Length[PreListPlot]-1}]],
                         Epilog ->{FontSize -> 15.,AbsoluteThickness[2.0],
                         {Dashed,Blue, Line[{{{\[Rho]0, 0}, {\[Rho]0, -20}}, {{\[Rho]1, 0}, {\[Rho]1, -20}}}]}, 
                         {Dotted, Red, Line[{{MMaskProj, 0}, {MMaskProj, -20}}]}, 
                         {Black, Line[{{\[Rho]0,Log10[cDarkHoleRegion]},{\[Rho]1,Log10[cDarkHoleRegion]}}]},
                         {Black,  Line[{{0.,Log10[cCoreRegion]},{\[Rho]0,Log10[cCoreRegion]}}]},
                         (*{Black,  Line[{{\[Rho]1,Log10[cSecondaryRegion]},{50.,Log10[cSecondaryRegion]}}]},*)
                         {Inset[Style["m/2=" <>ToString[PaddedForm[MMaskProj, {3, 2}]] <>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Red, FontFamily -> "Helvetica"],  {MMaskProj- 1.5, -8.}] },
                         {Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(i\)]\)=" <> ToString[PaddedForm[\[Rho]0, {2, 1}]]<>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Blue, FontFamily -> "Helvetica"],  {\[Rho]0+1.3, -10.}] },
                         {Inset[Style["\!\(\*SubscriptBox[\(\[Rho]\), \(o\)]\)=" <> ToString[PaddedForm[\[Rho]1, {2, 1}]]<>"\!\(\*SubscriptBox[\(\[Lambda]\), \(0\)]\)/D",Blue, FontFamily -> "Helvetica"],  {\[Rho]1+1.3, -10.}] },
                         {Inset[Style[PlotLabelPsfBw, FontFamily -> "Helvetica"],  {40, -11}] }
                         }]



(* ::Subsubsection::Closed:: *)
(*with DM*)


(* ::Text:: *)
(*iShift0 = (nShift + 1)/2;*)
(**)
(*PreListPlot = Table[Table[{Xi2D[[k2D]], Log10[PolyCoronoPSFLP2DDMNTable[[iShift, k2D, nImg2D/2 + 1]]]}, {k2D, 1, nImg2D}], {iShift, 1, nShift}];*)
(*ContrastListPlot[PreListPlot, MMaskProj, \[Rho]0, \[Rho]1, cCoreRegion, cSecondaryRegion, PlotLabelPsfBw, 15]*)
(**)


(* ::Subsection:: *)
(*2D radial cut profiles at all the wavelengths*)


(* ::Subsubsection:: *)
(*Without DM*)


PreListPlot = Table[Table[{Xi2D[[k2D]], Log10[FinalCoronoLP2DAllTable[[iShift0, i\[Lambda], nImg2D/2 + 1, k2D]]/FinalImageLP2D0AllTable[[iShift0, (n\[Lambda] + 1)/2, nImg2D/2 + 1, nImg2D/2 + 1]]]}, {k2D, 1, nImg2D}](*, {i\[Lambda], {1, (1 + n\[Lambda])/2, n\[Lambda]}}*), {i\[Lambda], 1, n\[Lambda]}];
ContrastListPlot[PreListPlot, MMaskProj, \[Rho]0, \[Rho]1, cCoreRegion, cSecondaryRegion, PlotLabelPsfBw, 15]


(* ::Subsubsection::Closed:: *)
(*With DM*)


(* ::Text:: *)
(*PreListPlot = Table[Table[{Xi2D[[k2D]], Log10[FinalCoronoLP2DDMAllTable[[iShift0, i\[Lambda], nImg2D/2 + 1, k2D]]/FinalImageLP2D0AllTable[[iShift0, (n\[Lambda] + 1)/2, nImg2D/2 + 1, nImg2D/2 + 1]]]}, {k2D, 1, nImg2D}](*, {i\[Lambda], {1, (1 + n\[Lambda])/2, n\[Lambda]}}*), {i\[Lambda], 1, n\[Lambda]}];*)
(*ContrastListPlot[PreListPlot, MMaskProj, \[Rho]0, \[Rho]1, cCoreRegion, cSecondaryRegion, PlotLabelPsfBw, 15]*)


(* ::Section::Closed:: *)
(*Averaged intensity profiles*)


(* ::Subsection::Closed:: *)
(*Monochromatic light *)


(* ::Text:: *)
(*Azimuthal averaged intensity profiles in monochromatic light *)


(* ::Text:: *)
(*AziMonoImagePSFLP2D0NTable = Table[0, {iShift, 1, nShift}];*)
(*AziMonoCoronoPSFLP2DNTable = Table[0, {iShift, 1, nShift}];*)


(* ::Text:: *)
(*Do[*)
(* AziMonoImagePSFLP2D0NTable[[iShift]] = AzimuthalAverage[FinalImageLP2D0AllTable[[iShift, (n\[Lambda] + 1)/2, All, All]]]; AziMonoCoronoPSFLP2DNTable[[iShift]] = AzimuthalAverage[FinalCoronoLP2DAllTable[[iShift, (n\[Lambda] + 1)/2, All, All]]];*)
(*     , {iShift, 1, nShift}]*)


(* ::Text:: *)
(*NormAziMonoImagePSFLP2D0NTable = Table[0, {iShift, 1, nShift}];*)
(*NormAziMonoCoronoPSFLP2DNTable = Table[0, {iShift, 1, nShift}];*)
(**)
(*Do[*)
(*  NormAziMonoImagePSFLP2D0NTable[[iShift]] = AziMonoImagePSFLP2D0NTable[[iShift, All]]/Max[AziMonoImagePSFLP2D0NTable[[1]]];*)
(*  NormAziMonoCoronoPSFLP2DNTable[[iShift]] = AziMonoCoronoPSFLP2DNTable[[iShift, All]]/Max[AziMonoImagePSFLP2D0NTable[[1]]];*)
(*     , {iShift, 1, nShift}];*)
(**)
(*Dimensions[NormAziMonoCoronoPSFLP2DNTable];*)


(* ::Subsubsection:: *)
(*Display - 1D azimuth averaged profile in monochromatic light*)


(* ::Text:: *)
(*Without DM*)


(* ::Text:: *)
(*iShift0 = (nShift + 1)/2;*)
(*PreListPlot = Table[Table[{Xi[[k1D]], Log10[NormAziMonoCoronoPSFLP2DNTable[[iShift, k1D]]]}, {k1D, 1, nImg}], {iShift, 1, nShift}];*)
(*ContrastListPlot[PreListPlot, MMaskProj, \[Rho]0, \[Rho]1, cCoreRegion, cSecondaryRegion, PlotLabelPsfMono, 15]*)
(**)


(* ::Subsection:: *)
(*Broadband light*)


(* ::Text:: *)
(*Azimuthal averaged intensity profiles in broadband light *)


AziPolyImagePSFLP2D0NTable = Table[0, {iShift, 1, nShift}];
AziPolyCoronoPSFLP2DNTable = Table[0, {iShift, 1, nShift}];
AziPolyCoronoPSFLP2DDMNTable = Table[0, {iShift, 1, nShift}];


Do[
  AziPolyImagePSFLP2D0NTable[[iShift]] = AzimuthalAverage[PolyImagePSFLP2D0NTable[[iShift, All, All]]]; AziPolyCoronoPSFLP2DNTable[[iShift]] = AzimuthalAverage[PolyCoronoPSFLP2DNTable[[iShift, All, All]]];
  AziPolyCoronoPSFLP2DDMNTable[[iShift]] = AzimuthalAverage[PolyCoronoPSFLP2DDMNTable[[iShift, All, All]]];
      , {iShift, 1, nShift}]


NormAziPolyImagePSFLP2D0NTable = Table[0, {iShift, 1, nShift}];
NormAziPolyCoronoPSFLP2DNTable = Table[0, {iShift, 1, nShift}];
NormAziPolyCoronoPSFLP2DDMNTable = Table[0, {iShift, 1, nShift}];

Do[
    NormAziPolyImagePSFLP2D0NTable[[iShift]] = AziPolyImagePSFLP2D0NTable[[iShift, All]]/Max[AziPolyImagePSFLP2D0NTable[[1]]];
    NormAziPolyCoronoPSFLP2DNTable[[iShift]] = AziPolyCoronoPSFLP2DNTable[[iShift, All]]/Max[AziPolyImagePSFLP2D0NTable[[1]]];
    NormAziPolyCoronoPSFLP2DDMNTable[[iShift]] = AziPolyCoronoPSFLP2DDMNTable[[iShift, All]]/Max[AziPolyImagePSFLP2D0NTable[[1]]];
       , {iShift, 1, nShift}];

Dimensions[NormAziPolyCoronoPSFLP2DNTable];


(* ::Subsubsection:: *)
(*1 D azimuth averaged profile in broadband light for all the Lyot stop shifts*)


(* ::Text:: *)
(*Without DM*)


(*iShift0 = (nShift + 1)/2;
PreListPlot = Table[Table[{Xi[[k1D]], Log10[NormAziPolyImagePSFLP2D0NTable[[iShift, k1D]]]}, {k1D, 1, nImg}], {iShift, 1, nShift}];
PSFContrastListPlot[PreListPlot, MMaskProj, PSF\[Rho]0, PSF\[Rho]1, cPSFCoreRegion, cPSFSecondaryRegion, PlotLabelPsfBw, 15]*)


PreListPlot = Table[Table[{Xi[[k1D]], Log10[NormAziPolyCoronoPSFLP2DNTable[[iShift, k1D]]]}, {k1D, 1, nImg}], {iShift, 1, nShift}];
ContrastListPlot[PreListPlot, MMaskProj, \[Rho]0, \[Rho]1, cCoreRegion, cSecondaryRegion, PlotLabelPsfBw, 20]


(* ::Text:: *)
(*With DM*)


(* ::Text:: *)
(*PreListPlot = Table[Table[{Xi[[k1D]], Log10[NormAziPolyCoronoPSFLP2DDMNTable[[iShift, k1D]]]}, {k1D, 1, nImg}], {iShift, 1, nShift}];*)
(*ContrastListPlot[PreListPlot, MMaskProj, \[Rho]0, \[Rho]1, cCoreRegion, cSecondaryRegion, PlotLabelPsfBw, 15]*)


(* ::Section::Closed:: *)
(*Contrast vs Lyot stop shift*)


(* ::Text:: *)
(*\[Rho]2D = nFmax2D/nImg2D*UndersizedPup*Table[Sqrt[(i - nImg2D/2 - 1)^2 + (j - nImg2D/2 - 1)^2], {i, 1, nImg2D}, {j, 1, nImg2D} ];*)


(* ::Text:: *)
(*DarkZonePts = Position[\[Rho]2D, _?((# >=  \[Rho]0)  && (# <=  \[Rho]1) &)];*)
(*DarkZoneArray = Table[0., {nImg2D}, {nImg2D} ];*)
(*Do[*)
(*    DarkZoneArray[[DarkZonePts[[i, 1]], DarkZonePts[[i, 2]]]] = 1.;*)
(*    , {i, 1, Length[DarkZonePts]}];*)
(**)


(* ::Text:: *)
(*AveragedDZContrast = Table[0., {nShift}];*)
(*Do[*)
(*  AveragedDZContrast[[iShift]] = Total[Log10[MonoCoronoImageArray[[iShift]]]*DarkZoneArray, 2]/Length[DarkZonePts];*)
(*  , {iShift, 1, nShift}]*)


(* ::Text:: *)
(*ShiftArray = Table[100.*(iShift - (nShift + 1)/2)*ShiftStep/(UndersizedPup*nPup), {iShift, 1, nShift}];*)


(* ::Text:: *)
(*Max[ShiftArray];*)


(* ::Text:: *)
(*PreListPlot = Table[{ShiftArray[[iShift]], AveragedDZContrast[[iShift]]}, {iShift, 1, nShift}];*)
(*ListPlot[PreListPlot, Joined -> True, PlotRange -> {{-1.6, 1.6}, {-11, -5}}, ImageSize -> Large, LabelStyle -> Directive[FontFamily -> "Helvetica", FontSize -> 15.], *)
(*   FrameLabel -> {"Shift in % Lyot stop size", "Averaged intensity in log scale"},*)
(*  FrameStyle -> AbsoluteThickness[1.1],*)
(*  PlotStyle -> If[Length[PreListPlot] > 1, Table[Directive[ColorData["Rainbow", i/(Length[PreListPlot] - 1)], AbsoluteThickness[2.0]], {i, 0, Length[PreListPlot] - 1}], Directive[ColorData["Rainbow", 1], AbsoluteThickness[2.0]]],*)
(*  Epilog -> {FontSize -> 15., AbsoluteThickness[2.0],*)
(*      {Black, Line[{{-10, Log10[cDarkHoleRegion]}, {10, Log10[cDarkHoleRegion]}}]}*)
(*      }]*)


(* ::Chapter:: *)
(*Throughput*)


(* ::Section:: *)
(*Total throughput*)


(* ::Text:: *)
(*Be careful, total throughput is different from Airy throughput*)


ApodizerThroughput=100.*(Total[ShapedPupil^2*Aperture^2, 2])/(Total[Aperture^2, 2]);
CoronagraphThroughput=100.*(Total[ShapedPupil^2*Aperture^2*LyotStop^2, 2])/(Total[Aperture^2, 2]);
"Apodizer throughput: " <> ToString[ApodizerThroughput] <> "%"
"Coronagraph throughput: " <> ToString[CoronagraphThroughput] <> "%"


(* ::Section::Closed:: *)
(*Airy throughput*)


(* ::Subsection::Closed:: *)
(*FWHM (tests for consistency with John Krist's Airy throughput definition)*)


(* ::Text:: *)
(*test1 = Position[PolyImagePSFLP2D00NTable[[(nShift + 1)/2, All, All]], _? (# >= 0.5 &)];*)


(* ::Text:: *)
(*Pts = Table[0., {nPupForLyotStopShift}, {nPupForLyotStopShift}];*)
(*Do[*)
(* Pts[[test1[[i, 1]], test1[[i, 2]]]] = 1.;*)
(* , {i, 1, Length[test1]}]*)


(* ::Text:: *)
(*FWHMArea = Total[Pts, 2]*)
(*FWHMPix = Sqrt[4.*FWHMArea/\[Pi]]*)
(*FWHM\[Lambda]overD = FWHMPix*nFmax2D/nImg2D*UndersizedPup*LyotStopShiftResizingFactor*)


(* ::Text:: *)
(*1.5*nImg2D/nFmax2D*1/(UndersizedPup*LyotStopShiftResizingFactor)*)


(* ::Text:: *)
(*ArrayPlot[Pts, ColorFunction -> GrayLevel]*)


(* ::Subsection::Closed:: *)
(*Airy disk tables for different sizes and centered on the optical axis*)


(* ::Text:: *)
(*AiryCircTable = Table[*)
(*   Cr\[EAcute]eCirc[PhotometricApertureRadiusTable[[iPhotometricAperture]]*nImg2D/nFmax2D*1/(UndersizedPup*LyotStopShiftResizingFactor), nImg2D], *)
(*   {iPhotometricAperture, 1, nPhotometricAperture}];*)


(* ::Text:: *)
(*Dimensions[AiryCircTable]*)


(* ::Text:: *)
(*ArrayPlot[AiryCircTable[[iPhotometricAperture0]], ColorFunction -> GrayLevel]*)


(* ::Text:: *)
(*AiryOnAxisCircPosTable = Table[Position[AiryCircTable[[iPhotometricAperture]], 1], {iPhotometricAperture, 1, nPhotometricAperture}];*)
(*Dimensions[AiryOnAxisCircPosTable]*)


(* ::Subsection::Closed:: *)
(*Encircled energy*)


(* ::Text:: *)
(*EE for clear telescope aperture*)


(* ::Text:: *)
(*EEClearApertureTable = Table[*)
(*   Total[Extract[PolyImagePSFLP2DCANTable[[(nShift + 1)/2, All, All]], AiryOnAxisCircPosTable[[iPhotometricAperture]]]], *)
(*   {iPhotometricAperture, 1, nPhotometricAperture}];*)


(* ::Text:: *)
(*EE for the considered telescope aperture*)


(* ::Text:: *)
(*EETelescopeTable = Table[*)
(*   Total[Extract[PolyImagePSFLP2D00NTable[[(nShift + 1)/2, All, All]], AiryOnAxisCircPosTable[[iPhotometricAperture]]]],*)
(*    {iPhotometricAperture, 1, nPhotometricAperture}];*)


(* ::Text:: *)
(*EE with telescope and SP for on PSF*)


(* ::Text:: *)
(*EEOnAxiswithShapedPupilTable = Table[*)
(*   Total[Extract[PolyImagePSFLP2D0NTable[[(nShift + 1)/2, All, All]], AiryOnAxisCircPosTable[[ iPhotometricAperture]]]], *)
(*   {iPhotometricAperture, 1, nPhotometricAperture}];*)


(* ::Subsection::Closed:: *)
(*Airy throughput for clear aperture and telescope aperture*)


(* ::Text:: *)
(*AiryThroughputTelescopeTable = Table[*)
(*   EETelescopeTable[[iPhotometricAperture]]/EEClearApertureTable[[iPhotometricAperture]], *)
(*   {iPhotometricAperture, 1, nPhotometricAperture}];*)


(* ::Text:: *)
(*"Telescope throughtput: " <> ToString[100.* AiryThroughputTelescopeTable[[iPhotometricAperture0]]] <> "%"*)


(* ::Text:: *)
(*AiryThroughputCenterTable = Table[*)
(*   EEOnAxiswithShapedPupilTable[[iPhotometricAperture]]/EETelescopeTable[[iPhotometricAperture]], *)
(*   {iPhotometricAperture, 1, nPhotometricAperture}];*)


(* ::Text:: *)
(*"Max Airy Throughtput (wrt telescope aperture): " <> ToString[ 100.*AiryThroughputCenterTable[[iPhotometricAperture0]]] <> "%"*)


(* ::Text:: *)
(*AiryThroughputCenterCATable = Table[*)
(*   EEOnAxiswithShapedPupilTable[[iPhotometricAperture]]/EEClearApertureTable[[iPhotometricAperture]],*)
(*   {iPhotometricAperture, 1, nPhotometricAperture}];*)


(* ::Text:: *)
(*"Max Airy Throughtput (wrt clear aperture): " <> ToString[ 100.*AiryThroughputCenterCATable[[iPhotometricAperture0]]] <> "%"*)


(* ::Chapter:: *)
(*Export*)


(* ::Section:: *)
(*Fits file*)


(* ::Subsection:: *)
(*No oversize*)


(* ::Subsubsection:: *)
(*Filenames*)


(* ::Text:: *)
(*Aperture*)


FitsFilenameAperture=StringReplace[FilenameApertureQuarter,{".dat" -> ".fits", "Aper_Q" -> "Aper_F", "N"<> PaddingForFileNames[nPup/2, 4] -> "N"<> PaddingForFileNames[nPup, 4]}];
FitsFilepathAperture=StringReplace[FileNameJoin[{FileDirectoryHiCATFiles, FitsFilenameAperture}], {"/dat/" ->  "/fits/"}]


(* ::Text:: *)
(*Shaped pupil*)


FitsFilenameShapedPupil=StringReplace[FilenameShapedPupilPartial,{ ".dat" -> ".fits","Aper_Q" -> "Aper_F","N"<> PaddingForFileNames[nPup/2, 4] -> "N"<> PaddingForFileNames[nPup, 4]}]
FitsFilepathShapedPupil=StringReplace[FileNameJoin[{FileDirectoryHiCATFiles, FitsFilenameShapedPupil}], {"/dat/" ->  "/fits/"}]


PDFFilenameShapedPupil=StringReplace[FilenameShapedPupilPartial,{"output_apodizers/dat/" -> "output_apodizers/pdf/", ".dat" -> ".pdf"}];
PDFFilepathShapedPupil=FileNameJoin[{FileDirectoryHiCATFiles, PDFFilenameShapedPupil}]


(* ::Text:: *)
(*Lyot stop*)


FitsFilenameLyotStop=StringReplace[FilenameLyotStopPartial,{ ".dat" -> ".fits", "N"<> PaddingForFileNames[nPup/2, 4] -> "N"<> PaddingForFileNames[nPup, 4]}];
FitsFilepathLyotStop=StringReplace[FileNameJoin[{FileDirectoryHiCATFiles, FitsFilenameLyotStop}], {"/dat/" ->  "/fits/"}]


(* ::Text:: *)
(*PSFs*)


PDFFilenamePSF=StringReplace[FilenameShapedPupilPartial,{ "output_apodizers/dat/"->"plots/",".dat" -> "_PSF.pdf"}];
PDFFilepathPSF= FileNameJoin[{FileDirectoryHiCATFiles,PDFFilenamePSF}]

PDFFilenameOffAxisPSF=StringReplace[FilenameShapedPupilPartial,{ "output_apodizers/dat/"->"plots/",".dat" -> "_OffAxisPSF.pdf"}];
PDFFilepathOffAxisPSF= FileNameJoin[{FileDirectoryHiCATFiles,PDFFilenameOffAxisPSF}]


(* ::Text:: *)
(*Radial Profiles*)


PDFFilenameRadialProfile=StringReplace[FilenameShapedPupilPartial,{ "output_apodizers/dat/"->"plots/",".dat" -> "_RadialProfile.pdf"}];
PDFFilepathRadialProfile= FileNameJoin[{FileDirectoryHiCATFiles,PDFFilenameRadialProfile}]

PDFFilenameOffAxisRadialProfile=StringReplace[FilenameShapedPupilPartial,{"output_apodizers/dat/"->"plots/", ".dat" -> "_OffAxisRadialProfile.pdf"}];
PDFFilepathOffAxisRadialProfile= FileNameJoin[{FileDirectoryHiCATFiles,PDFFilenameOffAxisRadialProfile}]


(* ::Subsubsection:: *)
(*Export*)


If[KeywordExportFitsFiles ==1,
(*Export[FitsFilepathAperture, Aperture];*)
Export[FitsFilepathShapedPupil, ShapedPupil(**Aperture*)];
(*Export[FitsFilepathLyotStop, LyotStop];*)
Export[PDFFilepathPSF,PSF];
Export[PDFFilepathShapedPupil,ApodizerPDF];
Export[PDFFilepathRadialProfile,RadialProfile];
]

If[KeywordExportFitsFiles ==1,
If[PSFKeyword==1,
Export[PDFFilepathOffAxisPSF,PSFOffAxis];
Export[PDFFilepathOffAxisRadialProfile,RadialProfileOffAxis];
]
]




(* ::Subsection:: *)
(*Oversize*)


(* ::Subsubsection:: *)
(*Filenames*)


(* ::Text:: *)
(*Aperture*)


FilenameSuperAperture = StringReplace[FilenameApertureFull, {"N0243" -> "N" <> PaddingForFileNames[nPupSuper, 4], ".dat" -> "_EDA"<> PaddingForFileNames[ResizingFactor, 2]<> ".dat"}];
FilepathSuperAperture = FileNameJoin[{FileDirectoryHiCATFiles, FilenameSuperAperture}]

FitsFilenameSuperAperture=StringReplace[FitsFilenameAperture, {"N" <> PaddingForFileNames[nPup, 4] -> "N" <> PaddingForFileNames[nPupSuper, 4], ".fits" -> "_EDA"<> PaddingForFileNames[ResizingFactor, 2]<> ".fits"}];
FitsFilepathSuperAperture=StringReplace[FileNameJoin[{FileDirectoryHiCATFiles, FitsFilenameSuperAperture}], {"/dat/" ->  "/fits/"}]


(* ::Text:: *)
(*Shaped Pupil*)


FilenameSuperShapedPupil = StringReplace[FilenameShapedPupilPartial, {"N0243" -> "N" <> PaddingForFileNames[nPupSuper, 4], ".dat" -> "_EDA"<> PaddingForFileNames[ResizingFactor, 2]<> "_MultFactor"<>PaddingForFileNames[MultFactor, 2]".dat"}];
FilepathSuperShapedPupil = FileNameJoin[{FileDirectoryHiCATFiles, FilenameSuperShapedPupil}]

FitsFilenameSuperShapedPupil=StringReplace[FilenameShapedPupilPartial, {"N0243" -> "N" <> PaddingForFileNames[nPupSuper, 4], ".dat" -> "_EDA"<> PaddingForFileNames[ResizingFactor, 2]<> "_MultFactor"<>PaddingForFileNames[IntegerPart[MultFactor*100], 3]<>".fits"}];
FitsFilepathSuperShapedPupil=StringReplace[FileNameJoin[{FileDirectoryHiCATFiles, FitsFilenameSuperShapedPupil}], {"/dat/" ->  "/fits/"}]


(* ::Text:: *)
(*Lyot stop*)


FilenameSuperLyotStop = StringReplace[FilenameLyotStopPartial, {"N0243" -> "N" <> PaddingForFileNames[nPupSuper, 4], ".dat" -> "_EDA"<> PaddingForFileNames[ResizingFactor, 2]<> ".dat"}];
FilepathSuperLyotStop = FileNameJoin[{FileDirectoryHiCATFiles, FilenameSuperLyotStop}]

FitsFilenameSuperLyotStop=StringReplace[FitsFilenameLyotStop, {"N" <> PaddingForFileNames[nPup, 4] -> "N" <> PaddingForFileNames[nPupSuper, 4], ".fits" -> "_EDA"<> PaddingForFileNames[ResizingFactor, 2]<> ".fits"}];
FitsFilepathSuperLyotStop=StringReplace[FileNameJoin[{FileDirectoryHiCATFiles, FitsFilenameSuperLyotStop}], {"/dat/" ->  "/fits/"}]


(* ::Subsubsection:: *)
(*Export*)


If[KeywordExportFitsFiles ==1,
If[ResizingFactor!= 1, 
Export[FitsFilepathSuperAperture, SuperAperture];
Export[FitsFilepathSuperShapedPupil, SuperShapedPupil*SuperAperture];
Export[FitsFilepathSuperLyotStop, SuperLyotStop];
]
]
